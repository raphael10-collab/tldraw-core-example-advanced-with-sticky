{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/createDesign.ts", "../../src/createState.ts", "../../src/testEventHandlerConditions.ts", "../../src/createEventChain.ts", "../../src/customError.ts", "../../src/utils.ts", "../../src/stateTree.ts", "../../src/getStateTreeFromDesign.ts", "../../src/types.ts"],
  "sourcesContent": ["import { createDesign } from './createDesign'\nimport { createState } from './createState'\n\nexport { createDesign, createState }\nexport * as S from './types'\n", "import type * as S from './types'\n\n/* -------------------------------------------------- */\n/*                    Create Design                   */\n/* -------------------------------------------------- */\n\nexport function createDesign<\n  D extends unknown,\n  R extends Record<string, S.Result<D>>,\n  C extends Record<string, S.Condition<D>>,\n  A extends Record<string, S.Action<D>>,\n  Y extends Record<string, S.Async<D>>,\n  T extends Record<string, S.Time<D>>,\n  V extends Record<string, S.Value<D>>\n>(design: S.Design<D, R, C, A, Y, T, V>): S.DesignWithHelpers<D, R, C, A, Y, T, V> {\n  return {\n    ...design,\n    createEventHandlerDesign: (eventHandlerDesign: S.EventHandlerDesign<D, R, C, A, T>) =>\n      eventHandlerDesign,\n    createEventHandlerObjectDesign: (\n      eventHandlerItemDesign: S.EventHandlerObjectDesign<D, R, C, A, T>\n    ) => eventHandlerItemDesign,\n    createAsyncEventDesign: (asyncEventDesign: S.AsyncEventDesign<D, R, C, A, Y, T>) =>\n      asyncEventDesign,\n    createRepeatEventDesign: (repeatEventDesign: S.RepeatEventDesign<D, R, C, A, T>) =>\n      repeatEventDesign,\n    createState: (stateDesign: S.StateDesign<D, R, C, A, Y, T, V>) => stateDesign,\n    createActionDesign: (actionDesign: S.ActionDesign<D, A>) => actionDesign,\n    createConditionDesign: (conditionDesign: S.ConditionDesign<D, C>) => conditionDesign,\n    createResultDesign: (resultDesign: S.ResultDesign<D, R>) => resultDesign,\n    createTimeDesign: (timeDesign: S.TimeDesign<D, T>) => timeDesign,\n    createValueDesign: (valueDesign: S.Value<D>) => valueDesign,\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { nanoid } from 'nanoid'\nimport { produce, enableMapSet, setAutoFreeze } from 'immer'\nimport { testEventHandlerConditions } from './testEventHandlerConditions'\nimport { createEventChain } from './createEventChain'\nimport type * as S from './types'\nimport * as StateTree from './stateTree'\nimport { getStateTreeFromDesign } from './getStateTreeFromDesign'\nimport customError from './customError'\nimport { castArray, last } from './utils'\n\nenableMapSet()\nsetAutoFreeze(false)\n\n/* -------------------------------------------------- */\n/*                Create State Designer               */\n/* -------------------------------------------------- */\n\n/**\n * Create a new state from a design object.\n * @param design The state's design object.\n * @public\n */\nexport function createState<\n  D,\n  R extends Record<string, S.Result<D>>,\n  C extends Record<string, S.Condition<D>>,\n  A extends Record<string, S.Action<D>>,\n  Y extends Record<string, S.Async<D>>,\n  T extends Record<string, S.Time<D>>,\n  V extends Record<string, S.Value<D>>\n>(design: S.Design<D, R, C, A, Y, T, V>): S.DesignedState<D, V> {\n  type ThisState = S.DesignedState<D, V>\n\n  const { options = {} } = design\n  const { suppressErrors = false, onSend } = options\n\n  let logEnabled = design.options?.enableLog\n\n  /* ----------------- Error Handling ----------------- */\n\n  function handleError(err: Error, prefix?: string) {\n    if (prefix) {\n      err.message = prefix + ': ' + err.message\n    }\n\n    if (design.options?.onError) {\n      design.options.onError(err)\n    }\n\n    if (suppressErrors) {\n      //   if (__DEV__) {\n      // console.error(err.message)\n      //   }\n      // } else {\n      throw err\n    } else {\n      throw err\n    }\n  }\n\n  /* ------------------ Subscriptions ----------------- \n  \n  A state can have one or more subscribers. A state's subscribers\n  are callbacks to fire when the state updates, and which will receive\n  the changed state.\n  */\n\n  const subscribers = new Set<S.SubscriberFn<Snapshot>>([])\n\n  /**\n   * Subscribe a callback to this state's updates. On each update, the state\n   * will call the callback with the state's new update.\n   * @param callbackFn The callback to subscribe.\n   */\n  function subscribe(callbackFn: S.SubscriberFn<Snapshot>) {\n    subscribers.add(callbackFn)\n  }\n\n  /**\n   * Unsubscribe a callback from the state. The callback will no longer be\n   * called when the state changes.\n   * @param callbackFn The callback to unsubscribe.\n   */\n  function unsubscribe(callbackFn: S.SubscriberFn<Snapshot>) {\n    if (subscribers.has(callbackFn)) {\n      subscribers.delete(callbackFn)\n    }\n\n    /* In some cases, intervals may persist past reloads, or when a \n    state is no longer needed. This solution is too blunt though: I can \n    imagine users wanting to keep a state's time ticking even when\n    components that depend on it are unmounted. Public method for\n    pause and resume? Activities with cleanup? */\n    if (subscribers.size === 0) {\n      stopLoop()\n      StateTree.recursivelyEndStateIntervals(snapshot.stateTree)\n    }\n  }\n\n  /**\n   * Call each subscriber callback with the current state.\n   */\n  function notifySubscribers() {\n    setValues()\n    setLog()\n    setActiveStates()\n    subscribers.forEach((subscriber) => subscriber(snapshot))\n  }\n\n  /* --------------------- Updates -------------------- */\n\n  /**\n   * Handle the outcome of an event handler chain.\n   * @param outcome The outcome of an event handler chain.\n   * @param payload The payload (if any) sent with the event that led to the event handler chain.\n   */\n  function handleEventHandlerChainOutcome(outcome: S.EventChainOutcome<ThisState>, payload: any) {\n    snapshot.data = outcome.data\n\n    for (const transition of outcome.pendingTransition) {\n      runTransition(transition, payload, outcome.result)\n    }\n  }\n\n  // Run event handler that updates the global `updates` object,\n  // useful for (more or less) synchronous eventss\n  function runEventHandlerChain(\n    state: S.State<ThisState>,\n    eventHandler: S.EventHandler<D>,\n    payload: any,\n    result: any\n  ) {\n    const outcome = createEventChain<ThisState>({\n      state,\n      data: snapshot.data,\n      result,\n      payload,\n      handler: eventHandler,\n      onDelayedOutcome: (outcome) => {\n        handleEventHandlerChainOutcome(outcome, payload)\n\n        if (outcome.shouldNotify) {\n          notifySubscribers()\n        }\n      },\n      getFreshDataAfterWait: () => snapshot.data,\n    })\n\n    handleEventHandlerChainOutcome(outcome, payload)\n\n    return outcome\n  }\n\n  // Try to run an event on a state. If active, it will run the corresponding\n  // event, if it has one; and, so long as there hasn't been a transition,\n  // will run its onEvent event, if it has one. If still no transition has\n  // occurred, it will move to try its child states.\n  function handleEventOnState(\n    state: S.State<ThisState>,\n    sent: S.Event\n  ): { shouldHalt: boolean; shouldNotify: boolean } {\n    const record = { shouldHalt: false, shouldNotify: false }\n\n    if (!state.active) return record\n\n    const activeChildren = Object.values(state.states).filter((state) => state.active)\n\n    const eventHandler = state.on[sent.event]\n\n    let outcome: S.EventChainOutcome<ThisState> | undefined = undefined\n\n    // Run event handler, if present\n    if (typeof eventHandler !== 'undefined') {\n      outcome = runEventHandlerChain(state, eventHandler, sent.payload, undefined)\n\n      if (outcome.shouldNotify) {\n        record.shouldNotify = true\n      }\n\n      if (outcome.shouldBreak) {\n        record.shouldNotify = true\n        record.shouldHalt = true\n        return record\n      }\n    }\n\n    // Run onEvent, if present\n    if (typeof state.onEvent !== 'undefined') {\n      outcome = runEventHandlerChain(state, state.onEvent, sent.payload, outcome?.result)\n\n      if (outcome.shouldNotify) {\n        record.shouldNotify = true\n      }\n\n      if (outcome.shouldBreak) {\n        record.shouldNotify = true\n        record.shouldHalt = true\n        return record\n      }\n    }\n    // Run event on states\n    for (const childState of activeChildren) {\n      const childRecord = handleEventOnState(childState, sent)\n\n      if (childRecord.shouldNotify) {\n        record.shouldNotify = true\n      }\n\n      if (childRecord.shouldHalt) {\n        record.shouldNotify = true\n        record.shouldHalt = true\n        return record\n      }\n    }\n\n    return record\n  }\n\n  /**\n   * Run a transition.\n   *\n   * @param path The path (or path segment) indicating the transition's target state.\n   * @param payload The payload (if any) sent along with the event that caused the transition.\n   * @param result The current result (if any) passed along from the event handler chain.\n   */\n  function runTransition(path: string, payload: any, result: any) {\n    const isPreviousTransition = path.endsWith('.previous')\n    const isRestoreTransition = path.endsWith('.restore')\n\n    if (isPreviousTransition) {\n      path = path.slice(0, path.length - 9)\n    } else if (isRestoreTransition) {\n      path = path.slice(0, path.length - 8)\n    }\n\n    // Get all states from the tree that match the target\n    const targets = StateTree.findTransitionTargets(snapshot.stateTree, path)\n\n    // Get the deepest matching target state\n    const target = last(targets)\n\n    if (typeof target === 'undefined') {\n      throw Error(`Error in transition (${path})! Could not find that state.`)\n    }\n\n    // Get the path of state names to the target state\n    const pathDown = target.path.split('.').slice(1)\n\n    // Get an array of states that are currently active (before the transition)\n    const beforeActive = StateTree.getActiveStates(snapshot.stateTree)\n\n    // Ok, time to change which states are active!\n\n    // 1. Deactivate the whole state tree\n    StateTree.deactivateState(snapshot.stateTree)\n\n    // 2. Update the initial states across the entire state tree.\n    StateTree.setIntitialStates(snapshot.stateTree, payload, snapshot.data)\n\n    // 3. Use the path to activate the tree again\n    StateTree.activateState(\n      snapshot.stateTree,\n      pathDown,\n      beforeActive,\n      isPreviousTransition || isRestoreTransition,\n      isRestoreTransition\n    )\n\n    // Get an array of states that are now active (after the transition)\n    const afterActive = StateTree.getActiveStates(snapshot.stateTree)\n\n    // Get an array of states that are no longer active\n    const deactivatedStates = beforeActive.filter((state) => !afterActive.includes(state))\n\n    // Get an array of states that have become active\n    const newlyActivatedStates = afterActive.filter((state) => !beforeActive.includes(state))\n\n    // Deactivated States\n    // - clear any interval\n    // - handle onExit events\n    // - bail if we've transitioned\n\n    deactivatedStates.forEach((state) => {\n      StateTree.endStateIntervals(state)\n      removeOnFrameEventHandler(state)\n    })\n\n    for (const state of deactivatedStates) {\n      const { onExit } = state\n      state.activeId++\n\n      if (typeof onExit !== 'undefined') {\n        const onExitOutcome = runEventHandlerChain(state, onExit, payload, result)\n        if (onExitOutcome.shouldBreak) return\n      }\n    }\n\n    // Activated States\n    // - set any repeat interval\n    // - handle onEnter events\n    // - bail if we've transitioned\n\n    for (const state of newlyActivatedStates) {\n      const { async, repeat, onEnter } = state\n\n      if (typeof repeat !== 'undefined') {\n        const { onRepeat, delay } = repeat\n\n        let now = performance.now()\n        // let lastTime: number | undefined = undefined\n        let elapsed = 0\n        let realInterval = 0\n\n        if (delay === undefined) {\n          // Add state to batched frame events and (maybe) start the loop\n          addOnFrameState(state, { payload, start: now })\n        } else {\n          // Run on provided delay amount\n          let lastTime = performance.now()\n\n          const s = delay(snapshot.data, payload, result)\n\n          state.times.interval = setInterval(() => {\n            now = performance.now()\n            realInterval = now - lastTime\n            elapsed += realInterval\n            lastTime = now\n\n            const outcome = runEventHandlerChain(state, onRepeat, payload, {\n              interval: realInterval,\n              elapsed,\n            })\n\n            if (outcome.shouldNotify) notifySubscribers()\n          }, Math.max(1 / 60, s * 1000))\n        }\n      }\n\n      if (typeof onEnter !== 'undefined') {\n        const onEnterOutcome = runEventHandlerChain(state, onEnter, payload, result)\n\n        if (onEnterOutcome.shouldBreak) return\n      }\n\n      if (typeof async !== 'undefined') {\n        let finished = false\n\n        state.times.cancelAsync = () => (finished = true)\n\n        async.await(snapshot.data, payload, result).then(\n          (resolved) => {\n            if (finished) return\n\n            const localUpdate = runEventHandlerChain(state, async.onResolve, payload, resolved)\n\n            if (localUpdate.shouldNotify) notifySubscribers()\n          },\n          (rejected) => {\n            if (typeof async.onReject !== 'undefined') {\n              if (finished) return\n\n              const localUpdate = runEventHandlerChain(state, async.onReject, payload, rejected)\n\n              if (localUpdate.shouldNotify) notifySubscribers()\n            }\n          }\n        )\n      } // End async handling\n    } // End for newlyActivatedStates\n  }\n\n  function enableLog(enabled: boolean) {\n    logEnabled = enabled\n  }\n\n  function logEvent(event: string) {\n    if (logEnabled) {\n      _log.unshift(event)\n    } else {\n      _log = [event]\n    }\n  }\n\n  function setLog() {\n    snapshot.index++\n    snapshot.log = [..._log]\n  }\n\n  function setValues() {\n    snapshot.values = getValues(snapshot.data, design.values)\n  }\n\n  function setActiveStates() {\n    _activeStates = StateTree.getActiveStates(snapshot.stateTree)\n    snapshot.active = getPaths(_activeStates)\n  }\n\n  /* ------------------ Per Frame Loop ---------------- \n\n  When states have an `onRepeat` event without a delay,\n  that event will be handled on every animation frame (usually\n  sixty times per second). These events are \"batched\" \u2014\n  iterated through on each frame, producing at most a single\n  synchronous update. We wouldn't want to have multiple\n  onRepeat events producing multiple separate updates per frame.\n\n  */\n\n  let lastTime = -1\n  let interval = -1\n  let frameInterval: number | undefined = undefined\n  type OnFrameInfo = { payload: any; start: number }\n  const onFrameStates = new Map<S.State<ThisState>, OnFrameInfo>([])\n\n  /**\n   * The main loop to run on each animation frame. Handles the `onRepeat` event on all\n   * states that have a per-frame repeat event.\n   * @param ms Current duration of the loop in milliseconds, as returned by requestAnimationFrame.\n   */\n  function loop(ms: number) {\n    let shouldNotify = false\n\n    if (lastTime < 0) lastTime = ms\n    interval = ms - lastTime\n    lastTime = ms\n\n    const states = Array.from(onFrameStates.entries())\n\n    for (const [state, info] of states) {\n      if (state.repeat?.onRepeat !== undefined) {\n        const outcome = runEventHandlerChain(state, state.repeat.onRepeat, info.payload, {\n          interval,\n          elapsed: ms - info.start,\n        })\n\n        if (outcome.shouldNotify) {\n          shouldNotify = true\n        }\n\n        if (outcome.shouldBreak) {\n          break\n        }\n      }\n    }\n\n    if (shouldNotify) notifySubscribers()\n\n    if (frameInterval === undefined) return\n\n    frameInterval = requestAnimationFrame(loop)\n  }\n\n  /**\n   * Stop the loop.\n   */\n  function stopLoop() {\n    if (frameInterval !== undefined) {\n      cancelAnimationFrame(frameInterval)\n      frameInterval = undefined\n      lastTime = -1\n      interval = -1\n    }\n  }\n\n  /**\n   * Start the loop.\n   */\n  function startLoop() {\n    frameInterval = requestAnimationFrame(loop)\n  }\n\n  /**\n   * Add a state to onFrameStates and start the loop, if it isn't already running\n   * @param state The state to add.\n   * @param info The payload and start time for this state's loop.\n   */\n  function addOnFrameState(state: S.State<ThisState>, info: OnFrameInfo) {\n    onFrameStates.set(state, info)\n    if (frameInterval === undefined) {\n      startLoop()\n    }\n  }\n\n  //\n  /**\n   * Remove a state from onFrameStates. Will stop the loop if there are no more repeating states\n   * @param state The state to remove.\n   */\n  function removeOnFrameEventHandler(state: S.State<ThisState>) {\n    if (onFrameStates.has(state)) {\n      onFrameStates.delete(state)\n      if (onFrameStates.size === 0) {\n        stopLoop()\n      }\n    }\n  }\n\n  /* ----------------- Public Methods ----------------- */\n\n  /**\n   * Subscribe a callback function to the state's updates. Each time\n   * the state updates (due to a successful transition or action), the\n   * state will call the callback with its new update. This function\n   * returns a second callback that will unsubscribe the callback.\n   * @param callbackFn\n   * @public\n   * @example\n   * const state = createState({ ... })\n   * const cancelUpdates = state.onUpdate((update) => { ... })\n   * if (allDone) cancelUpdates()\n   *\n   */\n  function onUpdate(callbackFn: S.SubscriberFn<Snapshot>) {\n    subscribe(callbackFn)\n    return () => unsubscribe(callbackFn)\n  }\n\n  /**\n   * Get an update from the current state without subscribing.\n   * @param callbackFn\n   * @public\n   */\n  function getUpdate(callbackFn: S.SubscriberFn<Snapshot>) {\n    setValues()\n    setActiveStates()\n    setLog()\n    callbackFn(snapshot)\n  }\n\n  /**\n   * Send an event to be processed. The state may be processing another event, but the events\n   * will settle synchronously. In particularly racey conditions, or where the event causes a\n   * new event to be send to the state, you may pass in a callback that will run when all\n   * queued events have settled.\n   * @param eventName The name of the event\n   * @param payload An (optional) payload of any type\n   * @param onSettle An (optional) callback to run when the event has settled.\n   * @public\n   */\n  function send(\n    eventName: string,\n    payload?: any,\n    onSettle?: (snapshot: Snapshot) => void\n  ): Snapshot {\n    try {\n      const { shouldNotify } = handleEventOnState(snapshot.stateTree, {\n        event: eventName,\n        payload,\n      })\n\n      logEvent(eventName)\n\n      if (shouldNotify) notifySubscribers()\n\n      onSettle?.(snapshot)\n\n      onSend?.(eventName, payload, shouldNotify)\n    } catch (e) {\n      handleError(e as any, eventName)\n    }\n\n    return snapshot\n  }\n\n  // Memoized calls to `send` when payloads aren't needed.\n  const sendCache = new Map<string, (eventName: string, payload?: any) => Snapshot>([])\n\n  function thenSend(eventName: string): (eventName: string, payload?: any) => Snapshot {\n    let cached = sendCache.get(eventName)\n\n    if (!cached) {\n      cached = () => send(eventName)\n      sendCache.set(eventName, cached)\n    }\n\n    return cached\n  }\n\n  /**\n   * Accepts one or more paths and returns true if the state tree has matching active states for every path.\n   * @param paths The paths to check\n   * @public\n   * @example\n   * state.isIn(\"playing\")\n   * state.isIn(\"playing.paused\")\n   * state.isIn(\"on\", \"stopped\") // true if BOTH states are active\n   *\n   */\n  function isIn(...paths: string[]): boolean {\n    try {\n      return castArray(paths)\n        .map((path) => (path.startsWith('.') ? path : '.' + path))\n        .every((path) => _activeStates.find((state) => state.path.endsWith(path)) !== undefined)\n    } catch (e) {\n      handleError(customError(`Error testing isIn(${paths.join()})!`, e as any))\n      return false\n    }\n  }\n\n  /**\n   * Accepts one or more paths and returns true if the state tree has matching active states for any path.\n   * @param paths The paths to check\n   * @public\n   * @example\n   * state.isIn(\"playing\")\n   * state.isIn(\"playing.paused\")\n   * state.isIn(\"on\", \"stopped\") // true if EITHER state is active\n   *\n   */\n  function isInAny(...paths: string[]): boolean {\n    try {\n      return castArray(paths)\n        .map((path) => (path.startsWith('.') ? path : '.' + path))\n        .some((path) => _activeStates.find((state) => state.path.endsWith(path)) !== undefined)\n    } catch (e) {\n      handleError(customError(`Error testing isInAny(${paths.join()})!`, e as any))\n      return false\n    }\n  }\n\n  /**\n   * Return true if the event could be handled and at least one of its handlers would pass its conditions, given the current state and payload.\n   * @param eventName The name of the event\n   * @param payload A payload of any type\n   * @public\n   */\n  function can(eventName: string, payload?: any, result?: any): boolean {\n    return (\n      typeof _activeStates.find((state) => {\n        const eventHandler = state.on[eventName]\n        if (typeof eventHandler === 'undefined') return\n\n        try {\n          return eventHandler.some((handler) => {\n            result = undefined\n\n            for (const resu of handler.get) {\n              result = resu(snapshot.data as D, payload, result)\n            }\n\n            return testEventHandlerConditions(handler, snapshot.data, payload, result)\n          })\n        } catch (e) {\n          handleError(customError(`Error testing can(${eventName})!`, e as any))\n          return false\n        }\n      }) !== 'undefined'\n    )\n  }\n\n  /**\n   * Get certain values when certain states are active. Contains a reducer to control how values are merged when multiple states are open.\n   * @param paths An object with paths as keys and a value to include if this path is active.\n   * @param reducer (optional) A function that will take all values from active paths and return an output.\n   * @param initial (optional) The reducer's initial value.\n   * @public\n   */\n  function whenIn<T = unknown>(\n    paths: Record<string, any>,\n    reducer: 'value' | 'array' | S.Reducer<T> = 'value',\n    initialValue?: any\n  ): T {\n    const entries: [string, any][] = []\n\n    Object.entries(paths).forEach(([key, value]) => {\n      const v = typeof value === 'function' ? value() : value\n      if (key === 'root') {\n        entries.push([key, v])\n      } else {\n        if (\n          _activeStates.find((v) => {\n            const safeKey = key.startsWith('.') ? key : '.' + key\n            return v.path.endsWith(safeKey)\n          })\n        ) {\n          entries.push([key, v])\n        }\n      }\n    })\n\n    if (entries.length === 0) {\n      if (typeof paths.default !== 'undefined') {\n        entries.push(['default', paths.default])\n      }\n    }\n\n    let returnValue: any\n    let rdcr: S.Reducer<T>\n\n    if (reducer === 'array') {\n      returnValue = []\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      rdcr = (a, [_, v]) => [...a, v] as any\n    } else if (reducer === 'value') {\n      returnValue = undefined\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      rdcr = (_, [__, v]) => v\n    } else {\n      returnValue = initialValue\n      rdcr = reducer\n    }\n\n    entries.forEach((entry, i) => (returnValue = rdcr(returnValue, entry, i, entries)))\n\n    return returnValue\n  }\n\n  /**\n   * Get the original design object (for debugging, mostly)\n   * @public\n   */\n  function getDesign() {\n    return design\n  }\n\n  /**\n   * Create a new state from this state's original design\n   * @public\n   */\n  function clone() {\n    return createState(design)\n  }\n\n  function forceTransition(target: string, payload?: string) {\n    logEvent(`Forced transition to: ${target}`)\n    runTransition(target, payload, undefined)\n    notifySubscribers()\n    return snapshot\n  }\n\n  function forceData(data: D): Snapshot {\n    snapshot.data = data\n    logEvent('Forced data.')\n    notifySubscribers()\n    return snapshot\n  }\n\n  /**\n   * Reset state based on original design.\n   */\n  function reset(): Snapshot {\n    stopLoop()\n    StateTree.recursivelyEndStateIntervals(snapshot.stateTree)\n    _log = []\n\n    Object.assign(snapshot, {\n      data: produce(design.data, (d) => d) as D,\n      stateTree: getStateTreeFromDesign(design, id),\n      log: [],\n    })\n\n    StateTree.deactivateState(snapshot.stateTree)\n    runTransition('root', undefined, undefined) // Will onEnter events matter?\n    notifySubscribers()\n\n    return snapshot\n  }\n\n  /* --------------------- Kickoff -------------------- */\n\n  const id = '#' + (typeof design.id !== 'undefined' ? `state_${nanoid()}` : design.id)\n  const initialStateTree = getStateTreeFromDesign(design, id)\n\n  let _log: string[] = []\n  let _activeStates = StateTree.getActiveStates(initialStateTree)\n\n  const snapshot = {\n    id,\n    data: produce(design.data, (d) => d) as D,\n    active: getPaths(_activeStates),\n    values: getValues(design.data as D, design.values),\n    stateTree: initialStateTree,\n    log: _log,\n    index: 0,\n    send,\n    thenSend,\n    isIn,\n    isInAny,\n    can,\n    whenIn,\n    getDesign,\n    onUpdate,\n    getUpdate,\n    enableLog,\n    forceData,\n    forceTransition,\n    clone,\n    reset,\n  }\n\n  type Snapshot = typeof snapshot\n\n  // Deactivate the tree, then activate it again to set initial active states.\n  StateTree.deactivateState(snapshot.stateTree)\n  runTransition('root', undefined, undefined) // Will onEnter events matter?\n  setValues()\n  setActiveStates()\n  setLog()\n\n  return snapshot\n}\n\n/* -------------------------------------------------- */\n/*                        Pure                        */\n/* -------------------------------------------------- */\n\n/**\n * Get paths from an array of states.\n * @param states A set of states\n */\nfunction getPaths<G extends S.DesignedState>(states: S.State<G>[]) {\n  return states.map((state) => state.path)\n}\n\n/**\n * Compute values based on the current data. A horrible affront to typescript.\n * @param data The current data state.\n */\nfunction getValues<D, V extends Record<string, S.Value<D>>>(\n  data: D,\n  values: V | undefined\n): S.Values<D, V> {\n  return Object.entries(values || {}).reduce<S.Values<D, V>>((acc, [key, fn]) => {\n    acc[key as keyof V] = fn(data as D)\n    return acc\n  }, {} as S.Values<D, V>)\n}\n", "import type * as S from './types'\n\n/**\n * Test whether a handler object would pass its conditions, given the current data, payload, and result.\n * @param h Handler\n * @param d Data\n * @param p Payload\n * @param r Result\n */\nexport function testEventHandlerConditions<D, P, R>(\n  h: S.EventHandlerObject<D> | S.InitialStateObject<D>,\n  d: D,\n  p: P,\n  r: R\n) {\n  try {\n    if (h.if[0] && !h.if.every((c) => c(d, p, r))) return false\n    if (h.ifAny[0] && !h.ifAny.some((c) => c(d, p, r))) return false\n    if (h.unless[0] && !h.unless.every((c) => !c(d, p, r))) return false\n    if (h.unlessAny[0] && !h.unlessAny.some((c) => !c(d, p, r))) return false\n    return true\n  } catch (e) {\n    throw Error(`Error while testing conditions! ` + (e as any).message)\n  }\n}\n", "import type * as S from './types'\nimport { createDraft, finishDraft, Draft } from 'immer'\nimport { testEventHandlerConditions } from './testEventHandlerConditions'\nimport customError from './customError'\n/**\n * Handle an event, along with its consequential events.\n * (Go get a cup of coffee because this is the hard part.)\n * An event chain will process an array of event handler\n * objects, each of which may include subchains (via `else`\n * or `then` properties). Depending on what these objects\n * do, we may have to update the data draft, break the\n * chain early, and/or set a flag to notify subscribers\n * of a change once we're done.\n * @param options\n */\nexport function createEventChain<G extends S.DesignedState>(\n  options: S.EventChainOptions<G>\n): S.EventChainOutcome<G> {\n  const { state, onDelayedOutcome, getFreshDataAfterWait } = options\n  const handlers = [...options.handler]\n  const { payload } = options\n\n  let waiting = false\n\n  let core: S.EventChainCore<G> = {\n    data: options.data,\n    payload: options.payload,\n    result: options.result,\n  }\n\n  const finalOutcome: S.EventChainOutcome<G> = {\n    ...core,\n    shouldBreak: false,\n    shouldNotify: false,\n    pendingTransition: [],\n  }\n\n  let draftCore: Draft<S.EventChainCore<G>> = createDraft(core)\n\n  let tResult = options.result\n\n  // Finish a draft and update the final outcome.\n  function complete(draft: Draft<S.EventChainCore<G>>) {\n    core = finishDraft(draft) as S.EventChainCore<G>\n    finalOutcome.result = core.result\n    finalOutcome.data = core.data\n  }\n\n  // Process an event handler object.\n  function processHandlerObject(\n    handler: S.EventHandlerObject<G>,\n    draft: Draft<S.EventChainCore<G>>\n  ): { shouldBreak: boolean } {\n    // Compute a result using original data and draft result\n    if (handler.get.length > 0) {\n      let fnName = ''\n      try {\n        for (const result of handler.get) {\n          fnName = result.name\n          tResult = result(draft.data as G['data'], payload, tResult)\n        }\n      } catch (e) {\n        throw customError(`Error in result (${fnName})!`, e as any)\n      }\n\n      // Save result to draft\n      draft.result = tResult\n    }\n\n    const passedConditions = testEventHandlerConditions(\n      handler,\n      draft.data as G['data'],\n      draft.payload,\n      draft.result\n    )\n\n    if (passedConditions) {\n      // Actions\n      if (handler.do.length > 0) {\n        finalOutcome.shouldNotify = true\n        let fnName = ''\n\n        try {\n          for (const action of handler.do) {\n            fnName = action.name\n            const result = action(draft.data as G['data'], draft.payload, draft.result)\n            if (result) {\n              Object.assign(draft.data, Object.freeze(result as G['data']))\n            }\n          }\n        } catch (e) {\n          throw customError(`Error in action (${fnName})!`, e as any)\n        }\n      }\n\n      // Secret actions\n      if (handler.secretlyDo.length > 0) {\n        let fnName = ''\n        try {\n          for (const action of handler.secretlyDo) {\n            fnName = action.name\n            const result = action(draft.data as G['data'], draft.payload, draft.result)\n\n            if (result) {\n              Object.assign(draft.data, Object.freeze(result as G['data']))\n            }\n          }\n        } catch (e) {\n          throw customError(`Error in secret action (${fnName})!`, e as any)\n        }\n      }\n\n      // Create human readable form of the draft.\n      // TODO: Do we have to do this for every object?\n\n      // Transitions\n      if (handler.to.length > 0) {\n        let fnName = ''\n        try {\n          for (const fn of handler.to) {\n            fnName = fn.name\n            finalOutcome.pendingTransition.push(\n              fn(draft.data as G['data'], draft.payload, draft.result)\n            )\n          }\n\n          finalOutcome.shouldBreak = true\n          finalOutcome.shouldNotify = true\n          return { shouldBreak: true }\n        } catch (e) {\n          throw customError(`Error computing transition (${fnName})!`, e as any)\n        }\n      }\n\n      // Secret Transitions (no notify)\n      if (handler.secretlyTo.length > 0) {\n        let fnName = ''\n        try {\n          for (const fn of handler.secretlyTo) {\n            fnName = fn.name\n            finalOutcome.pendingTransition.push(\n              fn(draft.data as G['data'], draft.payload, draft.result)\n            )\n          }\n\n          finalOutcome.shouldBreak = true\n          return { shouldBreak: true }\n        } catch (e) {\n          throw customError(`Error computing secret transition (${fnName})!`, e as any)\n        }\n      }\n\n      // Then\n      if (handler.then !== undefined) {\n        processEventHandler([...handler.then], draft)\n      }\n\n      // TODO: Is there a difference between break and halt? Halt breaks all,\n      // break breaks just one subchain, like else or then?\n\n      // Break\n      if (handler.break !== undefined) {\n        try {\n          if (handler.break(draft.data as G['data'], draft.payload, draft.result)) {\n            return { shouldBreak: true }\n          }\n        } catch (e) {\n          throw customError(`Error computing break (${handler.break.name})!`, e as any)\n        }\n      }\n    } else {\n      // Else (only if conditions failed)\n      if (handler.else !== undefined) {\n        processEventHandler([...handler.else], draft)\n      }\n    }\n\n    return { shouldBreak: false }\n  }\n\n  // Process an event handler (an array of event handler objects)\n  function processEventHandler(\n    eventHandler: S.EventHandler<G>,\n    draft: Draft<S.EventChainCore<G>>\n  ): { shouldBreakDueToWait: boolean } {\n    if (finalOutcome.shouldBreak) {\n      return { shouldBreakDueToWait: false }\n    }\n\n    const nextHandlerObject = eventHandler.shift()\n\n    if (nextHandlerObject === undefined) {\n      return { shouldBreakDueToWait: false }\n    } else if (nextHandlerObject.wait !== undefined) {\n      // Calculate wait time from finalOutcome draft\n      const waitTime =\n        nextHandlerObject.wait(draft.data as G['data'] as G['data'], payload, draft.result) * 1000\n\n      // Notify, if necessary\n      if (waiting && finalOutcome.shouldNotify) {\n        complete(draftCore)\n        onDelayedOutcome(finalOutcome)\n      }\n\n      waiting = true\n\n      // TODO: Does timeouts really need to be an array?\n      state.times.timeouts[0] = setTimeout(() => {\n        core.data = getFreshDataAfterWait() // After the timeout, refresh data\n        core.result = undefined // Results can't be carried across!\n\n        // Refresh\n        draftCore = createDraft(core)\n\n        const { shouldBreak } = processHandlerObject(nextHandlerObject, draftCore)\n\n        if (!shouldBreak) {\n          const { shouldBreakDueToWait } = processEventHandler(handlers, draftCore)\n\n          // If the event handler produced a wait, then it\n          // will have also refreshed the core and notified\n          // subscribers, if necessary.\n          if (shouldBreakDueToWait) {\n            return\n          }\n        }\n\n        complete(draftCore)\n        onDelayedOutcome(finalOutcome)\n      }, waitTime)\n\n      // Stop this chain\n      return { shouldBreakDueToWait: true }\n    } else {\n      // Continue with chain\n      const { shouldBreak } = processHandlerObject(nextHandlerObject, draft)\n\n      if (!shouldBreak) {\n        return processEventHandler(eventHandler, draft)\n      }\n\n      return { shouldBreakDueToWait: false }\n    }\n  }\n\n  processEventHandler(handlers, draftCore)\n\n  complete(draftCore)\n\n  return finalOutcome\n}\n", "export default function customError(message: string, error: Error) {\n  const err = new Error(message + ' ' + error.message)\n  err.stack = error.stack\n  return err\n}\n", "export function last<T>(array: T[]): T {\n  const length = array == null ? 0 : array.length\n  return array[length - 1] as T\n}\n\nexport function castArray(a: any | any[]) {\n  return Array.isArray(a) ? a : [a]\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type * as S from './types'\nimport { testEventHandlerConditions } from './testEventHandlerConditions'\nimport { last } from './utils'\n\n/**\n * Deactivate a state and its children.\n * Works recursively, so you should only call this on the state tree's root\n *\n * @param state\n */\nexport function deactivateState<G extends S.DesignedState>(state: S.State<G>) {\n  state.active = false\n  for (const childState of Object.values(state.states)) {\n    deactivateState(childState)\n  }\n}\n\n/**\n * Get an array of all active states in the current tree.\n * Works recursively, so you should only call this on the state tree's root.\n *\n * @param state The current state to examine.\n */\nexport function getActiveStates<G extends S.DesignedState>(state: S.State<G>) {\n  const acc: S.State<G>[] = []\n\n  if (state.active) {\n    acc.push(state)\n    for (const childState of Object.values(state.states)) {\n      acc.push(...getActiveStates(childState))\n    }\n  }\n\n  return acc\n}\n\n/**\n * Activate a state based on a path. This function will recursively activate all states in the path,\n * as well as children of those states as necessary. You should only call this on the root of\n * the state tree. See notes on ACTIVATING STATES.\n *\n * @param state The current state to activate.\n * @param path An array of state names.\n * @param before An array of states that were previously active.\n * @param prev Whether we should try to restore this state.\n * @param deep Whether we should also try to restore descendant states.\n */\nexport function activateState<G extends S.DesignedState>(\n  state: S.State<G>,\n  path: string[],\n  before: S.State<G>[],\n  prev: boolean,\n  deep: boolean\n) {\n  let isTarget = false\n  state.active = true\n\n  if (state.name === path[0]) {\n    path.shift()\n    if (path.length === 0) {\n      isTarget = true\n    }\n  }\n\n  if (state.initial === undefined) {\n    // Skipping Parallel\n    Object.values(state.states).forEach((c) => activateState(c, path, before, prev, deep))\n  } else if (prev && path.length === 0) {\n    // Restoring target (down-tree from target)\n    const c = state.states[last(state.history) || state.initial]\n    activateState(c, path, before, deep, deep)\n  } else if (state.states[path[0]] !== undefined) {\n    // Activating Next in Path\n    const c = state.states[path[0]]\n    state.history.push(c.name)\n    activateState(c, path, before, prev, deep)\n  } else if (!isTarget && before.includes(state)) {\n    // Restoring Unrelated (not target, not in path branch)\n    const c = state.states[last(state.history) || state.initial]\n    activateState(c, path, before, false, false)\n  } else {\n    // Activating Initial\n    const c = state.states[state.initial]\n    state.history.push(c.name)\n    activateState(c, path, before, false, false)\n  }\n}\n\n/**\n * Find all valid targets that match the provided path. Recursively searches the\n * state and its descendants, so you should only call this on the state tree's root.\n *\n * @param state\n * @param path\n */\nexport function findTransitionTargets<G extends S.DesignedState>(\n  state: S.State<G>,\n  path: string\n): S.State<G>[] {\n  const acc: S.State<G>[] = []\n\n  const safePath = path.startsWith('.') ? path : '.' + path\n\n  if (state.path.endsWith(safePath)) {\n    acc.push(state)\n  }\n\n  for (const childState of Object.values(state.states)) {\n    acc.push(...findTransitionTargets(childState, path))\n  }\n\n  return acc\n}\n\n/**\n * Compute a state's initial state, given the state's initialFn and the provided payload and data.\n *\n * @param initial\n * @param payload\n * @param data\n */\nexport function getInitialState<D>(\n  initial: S.InitialStateObject<D>,\n  payload: any,\n  data: D\n): string {\n  if (initial.else !== undefined) {\n    // Initial State with Logic\n    let result: any = undefined\n\n    for (const resu of initial.get) {\n      result = resu(data, payload, result)\n    }\n\n    if (testEventHandlerConditions(initial, data, payload, result)) {\n      // TODO: The initial state object design should not allow both a `then` and `else` property.\n      if (initial.then !== undefined) {\n        return getInitialState(initial.then, payload, data)\n      } else {\n        return initial.to(data, payload, result)\n      }\n    } else {\n      return getInitialState(initial.else, payload, data)\n    }\n  } else {\n    return initial.to(data, payload, undefined)\n  }\n}\n\n/**\n * Recursively set initial states. Call this function on the state tree before transitioning.\n *\n * @param state\n * @param payload\n * @param data\n */\nexport function setIntitialStates<G extends S.DesignedState>(\n  state: S.State<G>,\n  payload: any,\n  data: G['data']\n) {\n  if (state.initialFn !== undefined) {\n    state.initial = getInitialState(state.initialFn, payload, data)\n  }\n\n  if (state.states !== undefined) {\n    // Parallel State\n    for (const child of Object.values(state.states)) {\n      setIntitialStates(child, payload, data)\n    }\n  }\n}\n\nexport function endStateIntervals<G extends S.DesignedState>(state: S.State<G>) {\n  const { cancelAsync, timeouts, interval, animationFrame } = state.times\n\n  // If state is waiting on an asynchronous event, cancel it\n  if (cancelAsync !== undefined) {\n    cancelAsync()\n    state.times.cancelAsync = undefined\n  }\n\n  // If state is waiting on timeouts, clear them\n  for (const timeout of timeouts) {\n    clearTimeout(timeout)\n  }\n\n  state.times.timeouts = []\n\n  // If state is repeating an event on an interval, stop it\n  if (interval !== undefined) {\n    clearInterval(interval)\n    state.times.interval = undefined\n  }\n\n  // If the state is repeating an event on an animation frame, stop it\n  if (animationFrame !== undefined) {\n    cancelAnimationFrame(animationFrame)\n    state.times.animationFrame = undefined\n  }\n}\n\nexport function recursivelyEndStateIntervals<G extends S.DesignedState>(state: S.State<G>) {\n  endStateIntervals(state)\n  for (const child of Object.values(state.states)) {\n    recursivelyEndStateIntervals(child)\n  }\n}\n\n/* \n  ACTIVATING STATES\n\n  Activating states can be complex. We definitely want to make\n  this state active. If this state is next in the path, we \n  want to remove it from the path.\n\n  Next we check if it's a parallel state. Parallel states are easy. \n  If state is parallel, we activate all of its child states and \n  pass on the prev / restore arguments. Don't change their \n  histories\u2014parallel states don't need them. \n\n  If it's a branch state, then we'll either need to activate its\n  initial child state, \"restore\" it by activating its prevly \n  active state, or activate the next state in the path.\n\n  There are two types of transitions that might cause us to restore\n  a state: 'prev' and 'restore'. A prev transition only \n  restores the target state; a restore transition also restores the\n  target state's descendants.\n\n  What if we're not restoring this state?\n\n  If this state's children include the next state is in the path,\n  activate the state and pass on the transition's prev and\n  restore values. (We might still have a prev/restore transition \n  further down the path.)\n  \n  Otherwise, then what we do next depends on whether it was active \n  before the current transition. If it was active, then we'll want \n  to restore it back to how it was. If it was not active, then we'll\n  activate it \"normally\", according to its initial value, and pushing\n  to its history. */\n", "import { castArray } from './utils'\nimport type * as S from './types'\n\n/**\n * Turn a configuration object into a complete state tree, where shortcuts in the configuration\n * API are converted into a consistent structure.\n *\n * @param config A State Designer configuration object.\n */\nexport function getStateTreeFromDesign<\n  D extends unknown,\n  R extends Record<string, S.Result<D>>,\n  C extends Record<string, S.Condition<D>>,\n  A extends Record<string, S.Action<D>>,\n  Y extends Record<string, S.Async<D>>,\n  T extends Record<string, number | S.Time<D>>,\n  V extends Record<string, S.Value<D>>\n>(config: S.Design<D, R, C, A, Y, T, V>, id: string) {\n  // Convert times from raw numbers to EventFns\n  const times = Object.fromEntries(\n    Object.entries(config.times || {}).map(([k, v]) => {\n      return [k, castToFunction(v)]\n    })\n  ) as Record<Extract<keyof T, string>, S.Time<D>>\n\n  /**\n   * Convert an event function config into an event function.\n   * @param item\n   * @param collection\n   * @param collectionName\n   */\n  function getEventFn<T, K>(\n    item: Extract<keyof T, string> | S.EventFn<D, K>,\n    collection: Record<string, S.EventFn<D, K>> | undefined,\n    collectionName: string\n  ): S.EventFn<D, K> {\n    if (typeof item === 'string') {\n      if (!collection) {\n        throw Error(`No ${collectionName} in config!`)\n      } else {\n        const itemFromCollection = collection[item]\n        if (typeof itemFromCollection === 'undefined') {\n          throw Error(`No item in ${collectionName} named ${item}!`)\n        }\n\n        return itemFromCollection\n      }\n    } else {\n      return item\n    }\n  }\n\n  function castToNamedFunction<T>(item: T): () => T {\n    const fn = () => item\n    Object.defineProperty(fn, 'name', { value: item, writable: false })\n    return fn\n  }\n\n  function castToFunction<T extends string | number | boolean>(\n    item: T | S.EventFn<D, T> | undefined\n  ): S.EventFn<D, T> | undefined {\n    if (typeof item === 'undefined') return undefined\n    return typeof item === 'function' ? item : castToNamedFunction(item)\n  }\n\n  function getTransitions(items: S.TargetDesign<D> | undefined): S.Target<D>[] {\n    if (typeof items === 'undefined') return []\n    return castArray(items).map((item) =>\n      typeof item === 'function' ? item : castToNamedFunction(item)\n    )\n  }\n\n  function getResults(items: S.MaybeArray<S.ResultDesign<D, R>> | undefined) {\n    if (typeof items === 'undefined') return []\n    return castArray(items).map((item) => getEventFn(item, config.results, 'results'))\n  }\n\n  function getConditions(items: S.MaybeArray<S.ConditionDesign<D, C>> | undefined) {\n    if (typeof items === 'undefined') return []\n    return castArray(items).map((item) => getEventFn(item, config.conditions, 'conditions'))\n  }\n\n  function getActions(items: S.MaybeArray<S.ActionDesign<D, A>> | undefined) {\n    if (typeof items === 'undefined') return []\n    return castArray(items).map((item) => getEventFn(item, config.actions, 'actions'))\n  }\n\n  function getAsync(item: S.AsyncDesign<D, Y>) {\n    return getEventFn(item, config.asyncs, 'asyncs')\n  }\n\n  function getTime(item: S.TimeDesign<D, T> | undefined) {\n    if (typeof item === 'undefined') return undefined\n    return typeof item === 'number' ? castToNamedFunction(item) : getEventFn(item, times, 'times')\n  }\n\n  /**\n   * Convert an event handler item config into an event handler item.\n   * @param itemCfg\n   */\n  function getEventHandlerObject(\n    itemCfg: S.EventHandlerObjectDesign<D, R, C, A, T>\n  ): S.EventHandlerObject<D> {\n    return {\n      get: getResults(itemCfg.get),\n      if: getConditions(itemCfg.if),\n      ifAny: getConditions(itemCfg.ifAny),\n      unless: getConditions(itemCfg.unless),\n      unlessAny: getConditions(itemCfg.unlessAny),\n      do: getActions(itemCfg.do),\n      secretlyDo: getActions(itemCfg.secretlyDo),\n      to: getTransitions(itemCfg.to),\n      secretlyTo: getTransitions(itemCfg.secretlyTo),\n      wait: getTime(itemCfg.wait),\n      break: castToFunction(itemCfg.break),\n      then: itemCfg.then ? getEventHandler(itemCfg.then) : undefined,\n      else: itemCfg.else ? getEventHandler(itemCfg.else) : undefined,\n    }\n  }\n\n  /**\n   * Convert an event handler config into an event handler.\n   * @param event\n   */\n  function getEventHandler(event: S.EventHandlerDesign<D, R, C, A, T>): S.EventHandler<D> {\n    return castArray(event).map((eventHandler) => {\n      switch (typeof eventHandler) {\n        case 'string': {\n          if (typeof config.actions === 'undefined') {\n            throw new Error('Actions is undefined!')\n          } else {\n            const eventFn = config.actions && config.actions[eventHandler]\n            return getEventHandlerObject({ do: eventFn })\n          }\n        }\n        case 'function': {\n          return getEventHandlerObject({ do: eventHandler })\n        }\n        default: {\n          return getEventHandlerObject(eventHandler)\n        }\n      }\n    })\n  }\n\n  /**\n   * Convert an `initial` property (if present) into an initial state.\n   * @param initial The provided design for the state's initial state. Either a string or an object design (with or without logic).\n   */\n  function getInitialState(\n    initial?: string | S.InitialStateObjectDesign<D, C, R>\n  ): S.InitialStateObject<D> | undefined {\n    if (typeof initial === 'undefined') {\n      return\n    }\n\n    if (typeof initial === 'string' || !('else' in initial)) {\n      // No logic for the initial state\n      const target = typeof initial === 'string' ? initial : initial.to\n\n      return {\n        get: [],\n        if: [],\n        unless: [],\n        ifAny: [],\n        unlessAny: [],\n        to: typeof target === 'function' ? target : castToNamedFunction(target),\n      }\n    } else {\n      // Some logic for the initial state\n      return {\n        get: getResults(initial.get),\n        if: getConditions(initial.if),\n        unless: getConditions(initial.unless),\n        ifAny: getConditions(initial.ifAny),\n        unlessAny: getConditions(initial.unlessAny),\n        to: typeof initial.to === 'function' ? initial.to : castToNamedFunction(initial.to),\n        then: getInitialState(initial.then),\n        else: getInitialState(initial.else),\n      }\n    }\n  }\n\n  /**\n   * Convert a config into a state tree. Works recursively, so only call on the config.\n   * @param state\n   * @param name\n   * @param path\n   * @param active\n   */\n  function createState(\n    state: S.StateDesign<D, R, C, A, Y, T, V>,\n    name: string,\n    path: string,\n    active: boolean,\n    depth: number,\n    isInitial: boolean,\n    parentType: 'branch' | 'parallel' | 'leaf' | null\n  ): S.State<S.DesignedState> {\n    // Early error detection\n\n    if (state.initial !== undefined && state.states === undefined) {\n      throw Error(`In ${path + name}, you've provided an initial state but no states!`)\n    }\n\n    const type = state.states ? (state.initial ? 'branch' : 'parallel') : 'leaf'\n\n    return {\n      name,\n      type,\n      isInitial,\n      parentType,\n      depth,\n      path: path + name,\n      active,\n      activeId: 0,\n      history: [],\n      times: {\n        timeouts: [],\n        interval: undefined,\n        animationFrame: undefined,\n      },\n      initialFn: getInitialState(state.initial),\n      initial: undefined,\n      onEnter: state.onEnter ? getEventHandler(state.onEnter) : undefined,\n      onExit: state.onExit ? getEventHandler(state.onExit) : undefined,\n      onEvent: state.onEvent ? getEventHandler(state.onEvent) : undefined,\n      async: state.async\n        ? {\n            await: getAsync(state.async.await),\n            onResolve: getEventHandler(state.async.onResolve),\n            onReject: state.async.onReject ? getEventHandler(state.async.onReject) : undefined,\n          }\n        : undefined,\n      repeat: state.repeat\n        ? {\n            onRepeat: getEventHandler(state.repeat.onRepeat),\n            delay: state.repeat.delay ? getTime(state.repeat.delay) : undefined,\n          }\n        : undefined,\n      on: Object.fromEntries(\n        state.on\n          ? Object.entries(state.on).map(([name, event]) => [name, getEventHandler(event)])\n          : []\n      ),\n      states: Object.fromEntries(\n        state.states\n          ? Object.entries(state.states).map(([childName, childState]) => {\n              return [\n                childName,\n                createState(\n                  childState,\n                  childName,\n                  path + name + '.',\n                  false,\n                  depth + 1,\n                  state.initial === childName,\n                  type\n                ),\n              ]\n            })\n          : []\n      ),\n    }\n  }\n  return createState(config, 'root', id + '.', true, 0, true, null)\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nexport type MaybeArray<T> = T | T[]\n\nexport type Reducer<T> = (\n  acc: any,\n  entry: [string, any],\n  index: number,\n  array: [string, any][]\n) => T\n\n// Event Functions\n\nexport type EventFn<D, T> = (data: D, payload?: any, result?: any) => T\n\nexport type EventFnDesign<T, K> = Extract<keyof T, string> | K\n\n// Action\n\nexport type Action<D> = EventFn<D, Partial<D> | undefined | void>\n\nexport type ActionDesign<D, T> = EventFnDesign<\n  T,\n  EventFn<D, Partial<D> | undefined | void>\n>\n\n// Condition\n\nexport type Condition<D> = EventFn<D, boolean>\n\nexport type ConditionDesign<D, T> = EventFnDesign<T, Condition<D>>\n\n// Result\n\nexport type Result<D> = EventFn<D, any>\n\nexport type ResultDesign<D, T> = EventFnDesign<T, Result<D>>\n\n// Async\n\nexport type Async<D> = EventFn<D, Promise<any>>\n\nexport type AsyncDesign<D, T> = EventFnDesign<T, Async<D>>\n\n// Time\n\nexport type Time<D> = EventFn<D, number>\n\nexport type TimeDesign<D, T> = number | EventFnDesign<T, Time<D>>\n\n// Value\n\nexport type Value<D> = (data: D) => any\n\nexport type Values<D, V extends Record<string, Value<D>>> = {\n  [key in keyof V]: ReturnType<V[key]>\n}\n\nexport type ReturnedValues<D, V extends Record<string, Value<D>>> = {\n  [key in keyof V]: ReturnType<V[key]>\n}\n\n// Target\n\nexport type Target<D> = EventFn<D, string>\n\nexport type TargetDesign<D> = MaybeArray<string | EventFn<D, string>>\n\n// Send\n\nexport type Event = { event: string; payload: any }\n\n// Break\n\nexport type Break<D> = EventFn<D, boolean>\n\nexport type BreakDesign<D> = boolean | EventFn<D, boolean>\n\n// Intitial\n\nexport type InitialTargetDesign<D> = string | EventFn<D, string>\n\nexport type InitialStateObject<D> = {\n  get: Result<D>[]\n  if: Condition<D>[]\n  unless: Condition<D>[]\n  unlessAny: Condition<D>[]\n  ifAny: Condition<D>[]\n  to: Target<D>\n  then?: InitialStateObject<D>\n  else?: InitialStateObject<D>\n}\n\nexport type InitialStateObjectDesign<D, C, R> =\n  | InitialStateObjectDesignWithoutLogic<D>\n  | InitialStateObjectDesignWithLogic<D, C, R>\n\nexport type InitialStateObjectDesignWithoutLogic<D> =\n  | string\n  | {\n      to: InitialTargetDesign<D>\n    }\n\nexport type InitialStateObjectDesignWithLogic<D, C, R> = {\n  get?: MaybeArray<ResultDesign<D, R>>\n  if?: MaybeArray<ConditionDesign<D, C>>\n  unless?: MaybeArray<ConditionDesign<D, C>>\n  ifAny?: MaybeArray<ConditionDesign<D, C>>\n  unlessAny?: MaybeArray<ConditionDesign<D, C>>\n  else: InitialStateObjectDesign<D, C, R>\n  to: InitialTargetDesign<D>\n  then: InitialStateObjectDesign<D, C, R>\n}\n\nexport type InitialStateDesign<D, C, R> =\n  | string\n  | InitialStateObjectDesign<D, C, R>\n\n// Event Handler Object\n\nexport type EventHandlerObject<D> = {\n  get: Result<D>[]\n  if: Condition<D>[]\n  unless: Condition<D>[]\n  ifAny: Condition<D>[]\n  unlessAny: Condition<D>[]\n  do: Action<D>[]\n  secretlyDo: Action<D>[]\n  to: Target<D>[]\n  secretlyTo: Target<D>[]\n  wait?: Time<D>\n  break?: Break<D>\n  then?: EventHandler<D>\n  else?: EventHandler<D>\n}\n\n/**\n * What to do when an event is triggered. You can define an event as an array of these objects.\n */\nexport type EventHandlerObjectDesign<D, R, C, A, T> = {\n  /**\n   * The result(s) to compute before running conditions or actions. The returned value will be available as the third argument to event handler functions, such as conditions, actions, and further restults.\n   */\n  get?: MaybeArray<ResultDesign<D, R>>\n  /**\n   * One or more condition(s) to test. If any condition returns false, the handler will not run.\n   */\n  if?: MaybeArray<ConditionDesign<D, C>>\n  /**\n   * One or more condition(s) to test. If any condition returns true, the handler will run.\n   */\n  ifAny?: MaybeArray<ConditionDesign<D, C>>\n  /**\n   * One or more condition(s) to test. If any condition returns true, the handler will not run.\n   */\n  unless?: MaybeArray<ConditionDesign<D, C>>\n  /**\n   * One or more condition(s) to test. If any condition returns false, the handler will run.\n   */\n  unlessAny?: MaybeArray<ConditionDesign<D, C>>\n  /**\n   * The action(s) to perform. These actions can mutate the data property. Note: Defining actions will cause this event to trigger an update.\n   */\n  do?: MaybeArray<ActionDesign<D, A>>\n  /**\n   * The \"secret\" action(s) to perform. These actions cannot mutate the data property. Note: Defining \"secret\" actions will NOT cause this event to trigger an update.\n   */\n  secretlyDo?: MaybeArray<ActionDesign<D, A>>\n  /**\n   * A transition target: either a state's name or path. Defining a target will cause this handler to trigger an update.\n   */\n  to?: TargetDesign<D>\n  /**\n   * A transition target: either a state's name or path. Defining a target will not cause this handler to trigger an update.\n   */\n  secretlyTo?: TargetDesign<D>\n  /**\n   * A delay (in seconds) to wait before running this handler object.\n   */\n  wait?: TimeDesign<D, T>\n  /**\n   * Whether this item should stop the event's other handlers objects from running.\n   */\n  break?: BreakDesign<D>\n  /**\n   * An additional event handler to run if this event handler object passed its conditions.\n   */\n  then?: EventHandlerDesign<D, R, C, A, T>\n  /**\n   * An event handler to run instead if this event handler object did not pass its conditions.\n   */\n  else?: EventHandlerDesign<D, R, C, A, T>\n}\n\n// Event Handler\n\nexport type EventHandler<D> = Array<EventHandlerObject<D>>\n\nexport type EventHandlerDesign<D, R, C, A, T> = MaybeArray<\n  ActionDesign<D, A> | EventHandlerObjectDesign<D, R, C, A, T>\n>\n\nexport type RepeatEvent<D> = {\n  onRepeat: EventHandler<D>\n  delay?: Time<D>\n}\n\nexport type RepeatEventDesign<D, R, C, A, T> = {\n  onRepeat: EventHandlerDesign<D, R, C, A, T>\n  delay?: TimeDesign<D, T>\n}\n// Async Event Handler\n\nexport type AsyncEvent<D> = {\n  await: Async<D>\n  onResolve: EventHandler<D>\n  onReject?: EventHandler<D>\n}\n\nexport type AsyncEventDesign<D, R, C, A, Y, T> = {\n  await: Extract<keyof Y, string> | Async<D>\n  onResolve: EventHandlerDesign<D, R, C, A, T>\n  onReject?: EventHandlerDesign<D, R, C, A, T>\n}\n\n// Verbose Logging Types\n\nexport enum VerboseType {\n  Condition = 'condition',\n  Action = 'action',\n  SecretAction = 'secretAction',\n  Event = 'event',\n  State = 'state',\n  AsyncEvent = 'asyncEvent',\n  TransitionEvent = 'transitionEvent',\n  RepeatEvent = 'repeatEvent',\n  Transition = 'transition',\n  Notification = 'notification',\n  EventHandler = 'eventHandler',\n  Queue = 'queue',\n}\n\n// State\n\nexport interface State<G extends DesignedState> {\n  name: string\n  isInitial: boolean\n  parentType: 'branch' | 'leaf' | 'parallel' | null\n  depth: number\n  type: 'branch' | 'leaf' | 'parallel'\n  active: boolean\n  path: string\n  history: string[]\n  activeId: number\n  times: {\n    timeouts: any[]\n    interval?: any\n    animationFrame?: number\n    cancelAsync?: () => void\n  }\n  on: Record<string, EventHandler<G['data']>>\n  onEnter?: EventHandler<G['data']>\n  onExit?: EventHandler<G['data']>\n  onEvent?: EventHandler<G['data']>\n  repeat?: RepeatEvent<G['data']>\n  async?: AsyncEvent<G['data']>\n  states: Record<string, State<G>>\n  initialFn?: InitialStateObject<G['data']>\n  initial?: string\n}\n\nexport interface StateDesign<D, R, C, A, Y, T, V> {\n  on?: Record<string, EventHandlerDesign<D, R, C, A, T>>\n  onEnter?: EventHandlerDesign<D, R, C, A, T>\n  onExit?: EventHandlerDesign<D, R, C, A, T>\n  onEvent?: EventHandlerDesign<D, R, C, A, T>\n  repeat?: RepeatEventDesign<D, R, C, A, T>\n  async?: AsyncEventDesign<D, R, C, A, Y, T>\n  states?: Record<string, StateDesign<D, R, C, A, Y, T, V>>\n  initial?: InitialStateDesign<D, C, R>\n}\n\nexport interface DesignOptions {\n  enableLog?: boolean\n  suppressErrors?: boolean\n  onError?: (error: Error) => void\n  onSend?: (eventName: string, payload: any, didCauseUpdate: boolean) => void\n}\n\n// Design\n\nexport interface Design<\n  D,\n  R extends Record<string, Result<D>> = any,\n  C extends Record<string, Condition<D>> = any,\n  A extends Record<string, Action<D>> = any,\n  Y extends Record<string, Async<D>> = any,\n  T extends Record<string, number | Time<D>> = any,\n  V extends Record<string, Value<D>> = any\n> extends StateDesign<D, R, C, A, Y, T, V> {\n  id?: string\n  data?: D\n  results?: R\n  conditions?: C\n  actions?: A\n  asyncs?: Y\n  times?: T\n  values?: V\n  options?: DesignOptions\n}\n\nexport interface DesignWithHelpers<\n  D,\n  R extends Record<string, Result<D>>,\n  C extends Record<string, Condition<D>>,\n  A extends Record<string, Action<D>>,\n  Y extends Record<string, Async<D>>,\n  T extends Record<string, number | Time<D>>,\n  V extends Record<string, Value<D>>\n> extends Design<D, R, C, A, Y, T, V> {\n  createEventHandlerDesign: (\n    design: EventHandlerDesign<D, R, C, A, T>\n  ) => EventHandlerDesign<D, R, C, A, T>\n  createEventHandlerObjectDesign: (\n    design: EventHandlerObjectDesign<D, R, C, A, T>\n  ) => EventHandlerObjectDesign<D, R, C, A, T>\n  createAsyncEventDesign: (\n    design: AsyncEventDesign<D, R, C, A, Y, T>\n  ) => AsyncEventDesign<D, R, C, A, Y, T>\n  createRepeatEventDesign: (\n    design: RepeatEventDesign<D, R, C, A, T>\n  ) => RepeatEventDesign<D, R, C, A, T>\n  createState: (\n    design: StateDesign<D, R, C, A, Y, T, V>\n  ) => StateDesign<D, R, C, A, Y, T, V>\n  createResultDesign: (design: ResultDesign<D, R>) => ResultDesign<D, R>\n  createConditionDesign: (\n    design: ConditionDesign<D, C>\n  ) => ConditionDesign<D, C>\n  createActionDesign: (design: ActionDesign<D, A>) => ActionDesign<D, A>\n  createTimeDesign: (design: TimeDesign<D, T>) => TimeDesign<D, T>\n  createValueDesign: (design: Value<D>) => Value<D>\n}\n\n// Subscribers\n\nexport type SubscriberFn<T> = (update: T) => void\n\n// State Design\n\nexport interface DesignedState<\n  D = any,\n  V extends Record<string, Value<D>> | never = any\n> {\n  id: string\n  index: number\n  data: D\n  values: Values<D, V>\n  active: string[]\n  stateTree: State<this>\n  log: string[]\n  can: (eventName: string, payload?: any) => boolean\n  isIn: (...paths: string[]) => boolean\n  isInAny: (...paths: string[]) => boolean\n  whenIn: <T = unknown>(\n    states: { [key: string]: any },\n    reducer?: 'value' | 'array' | Reducer<T>,\n    initial?: any\n  ) => T\n  thenSend: (eventName: string) => (eventName: string, payload?: any) => this\n  send: (eventName: string, payload?: any) => this\n  onUpdate: (callbackFn: SubscriberFn<this>) => () => void\n  getUpdate: (callbackFn: SubscriberFn<this>) => void\n  getDesign: () => any\n  forceData: (data: D) => this\n  forceTransition: (target: string, payload?: any) => this\n  clone: () => this\n  reset: () => this\n  enableLog: (enabled: boolean) => void\n}\n\n// State with Design\n\nexport type StateWithDesign<\n  State extends Design<unknown, any, any, any, any, any, any>\n> = DesignedState<State['data'], Values<State['data'], State['values']>>\n\n// Event Handler Chains\n\nexport type EventChainOptions<G extends DesignedState> = {\n  state: State<G>\n  data: G['data']\n  result: any\n  payload: any\n  handler: EventHandler<G['data']>\n  onDelayedOutcome: EventChainCallback<G>\n  getFreshDataAfterWait: () => G['data']\n}\n\nexport type EventChainCore<G extends DesignedState> = {\n  data: G['data']\n  payload: any\n  result: any\n}\n\nexport type EventChainOutcome<G extends DesignedState> = {\n  data: G['data']\n  result: any\n  shouldBreak: boolean\n  shouldNotify: boolean\n  pendingTransition: string[]\n}\n\nexport type EventChainCallback<G extends DesignedState> = (\n  outcome: EventChainOutcome<G>\n) => void\n"],
  "mappings": "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",
  "names": []
}
