import type * as S from './types';
/**
 * Deactivate a state and its children.
 * Works recursively, so you should only call this on the state tree's root
 *
 * @param state
 */
export declare function deactivateState<G extends S.DesignedState>(state: S.State<G>): void;
/**
 * Get an array of all active states in the current tree.
 * Works recursively, so you should only call this on the state tree's root.
 *
 * @param state The current state to examine.
 */
export declare function getActiveStates<G extends S.DesignedState>(state: S.State<G>): S.State<G>[];
/**
 * Activate a state based on a path. This function will recursively activate all states in the path,
 * as well as children of those states as necessary. You should only call this on the root of
 * the state tree. See notes on ACTIVATING STATES.
 *
 * @param state The current state to activate.
 * @param path An array of state names.
 * @param before An array of states that were previously active.
 * @param prev Whether we should try to restore this state.
 * @param deep Whether we should also try to restore descendant states.
 */
export declare function activateState<G extends S.DesignedState>(state: S.State<G>, path: string[], before: S.State<G>[], prev: boolean, deep: boolean): void;
/**
 * Find all valid targets that match the provided path. Recursively searches the
 * state and its descendants, so you should only call this on the state tree's root.
 *
 * @param state
 * @param path
 */
export declare function findTransitionTargets<G extends S.DesignedState>(state: S.State<G>, path: string): S.State<G>[];
/**
 * Compute a state's initial state, given the state's initialFn and the provided payload and data.
 *
 * @param initial
 * @param payload
 * @param data
 */
export declare function getInitialState<D>(initial: S.InitialStateObject<D>, payload: any, data: D): string;
/**
 * Recursively set initial states. Call this function on the state tree before transitioning.
 *
 * @param state
 * @param payload
 * @param data
 */
export declare function setIntitialStates<G extends S.DesignedState>(state: S.State<G>, payload: any, data: G['data']): void;
export declare function endStateIntervals<G extends S.DesignedState>(state: S.State<G>): void;
export declare function recursivelyEndStateIntervals<G extends S.DesignedState>(state: S.State<G>): void;
