import {
  e
} from "./chunk-ZKTTN3E6.js";
import "./chunk-TWLJ45QX.js";

// ../../packages/core/node_modules/@tldraw/intersect/dist/index.mjs
var A = Object.defineProperty;
var M = Object.defineProperties;
var q = Object.getOwnPropertyDescriptors;
var X = Object.getOwnPropertySymbols;
var V = Object.prototype.hasOwnProperty;
var $ = Object.prototype.propertyIsEnumerable;
var Y = (e2, n, t) => n in e2 ? A(e2, n, { enumerable: true, configurable: true, writable: true, value: t }) : e2[n] = t;
var g = (e2, n) => {
  for (var t in n || (n = {}))
    V.call(n, t) && Y(e2, t, n[t]);
  if (X)
    for (var t of X(n))
      $.call(n, t) && Y(e2, t, n[t]);
  return e2;
};
var T = (e2, n) => M(e2, q(n));
function l(e2, ...n) {
  return { didIntersect: n.length > 0, message: e2, points: n };
}
function I(e2, n, t = 0) {
  let r = [e2[0] + n[0] / 2, e2[1] + n[1] / 2], i = e.rotWith(e2, r, t), u = e.rotWith(e.add(e2, [n[0], 0]), r, t), s = e.rotWith(e.add(e2, n), r, t), o = e.rotWith(e.add(e2, [0, n[1]]), r, t);
  return [["top", [i, u]], ["right", [u, s]], ["bottom", [s, o]], ["left", [o, i]]];
}
function v(e2, n, t) {
  if (t === e2 || t === n)
    return true;
  let r = Math.PI * 2, i = (n - e2 + r) % r, u = (t - e2 + r) % r;
  return i <= Math.PI != u > i;
}
function ie(e2, n) {
  let t = e.slope(e2[0], e2[1]), r = e.slope(n[0], n[1]);
  if (t === r)
    return;
  if (Number.isNaN(t) && !Number.isNaN(r))
    return [e2[0][0], (e2[0][0] - n[0][0]) * r + n[0][1]];
  if (Number.isNaN(r) && !Number.isNaN(t))
    return [n[0][0], (n[0][0] - e2[0][0]) * t + e2[0][1]];
  let i = (t * e2[0][0] - r * n[0][0] + n[0][1] - e2[0][1]) / (t - r), u = r * (i - n[0][0]) + n[0][1];
  return [i, u];
}
function ue(e2, n, t, r) {
  let i = t[0] - e2[0], u = t[1] - e2[1], s = r[0] * n[1] - r[1] * n[0], o = (u * r[0] - i * r[1]) / s, c = (u * n[0] - i * n[1]) / s;
  if (o < 0 || c < 0)
    return l("miss");
  let m = n[1] / n[0], b = r[1] / r[0], f = e2[1] - m * e2[0], L = (t[1] - b * t[0] - f) / (m - b), h = m * L + f;
  return Number.isFinite(L) ? l("intersection", [L, h]) : l("parallel");
}
function x(e2, n, t, r) {
  let [i, u] = e2, [s, o] = n, [c, m] = t, [b, f] = r;
  if (o / s !== (f - m) / (b - c)) {
    let p = s * (f - m) - o * (b - c);
    if (p !== 0) {
      let L = ((u - m) * (b - c) - (i - c) * (f - m)) / p, h = ((u - m) * s - (i - c) * o) / p;
      if (L >= 0 && h >= 0 && h <= 1)
        return l("intersection", [i + L * s, u + L * o]);
    }
  }
  return l("no intersection");
}
function N(e2, n, t, r, i = 0) {
  return G(t, r, i, e2, n);
}
function F(e2, n, t, r, i, u) {
  let s = e2, o = e.mul(n, 999999999);
  return y(s, o, t, r, i, u);
}
function se(e2, n, t, r = 0) {
  let { minX: i, minY: u, width: s, height: o } = t;
  return N(e2, n, [i, u], [s, o], r);
}
function oe(e2, n, t, r) {
  return x(t, r, e2, n);
}
function B(e2, n, t, r) {
  let i = e.sub(e2, t), u = e.sub(r, t), s = e.sub(n, e2), o = u[0] * i[1] - u[1] * i[0], c = s[0] * i[1] - s[1] * i[0], m = u[1] * s[0] - u[0] * s[1];
  if (o === 0 || c === 0)
    return l("coincident");
  if (m === 0)
    return l("parallel");
  if (m !== 0) {
    let b = o / m, f = c / m;
    if (0 <= b && b <= 1 && 0 <= f && f <= 1)
      return l("intersection", e.add(e2, e.mul(s, b)));
  }
  return l("no intersection");
}
function j(e2, n, t, r) {
  return E(t, r, e2, n);
}
function k(e2, n, t, r, i, u) {
  let s = e.angle(t, i), o = e.angle(t, u), c = U(t, r, r, 0, e2, n);
  if (!c.didIntersect)
    return l("no intersection");
  let m = c.points.filter((b) => v(s, o, e.angle(t, b)));
  return m.length === 0 ? l("no intersection") : l("intersection", ...m);
}
function R(e2, n, t, r) {
  let i = (n[0] - e2[0]) * (n[0] - e2[0]) + (n[1] - e2[1]) * (n[1] - e2[1]), u = 2 * ((n[0] - e2[0]) * (e2[0] - t[0]) + (n[1] - e2[1]) * (e2[1] - t[1])), s = t[0] * t[0] + t[1] * t[1] + e2[0] * e2[0] + e2[1] * e2[1] - 2 * (t[0] * e2[0] + t[1] * e2[1]) - r * r, o = u * u - 4 * i * s;
  if (o < 0)
    return l("outside");
  if (o === 0)
    return l("tangent");
  let c = Math.sqrt(o), m = (-u + c) / (2 * i), b = (-u - c) / (2 * i);
  if ((m < 0 || m > 1) && (b < 0 || b > 1))
    return m < 0 && b < 0 || m > 1 && b > 1 ? l("outside") : l("inside");
  let f = [];
  return 0 <= m && m <= 1 && f.push(e.lrp(e2, n, m)), 0 <= b && b <= 1 && f.push(e.lrp(e2, n, b)), l("intersection", ...f);
}
function y(e2, n, t, r, i, u = 0) {
  if (r === 0 || i === 0 || e.isEqual(e2, n))
    return l("no intersection");
  r = r < 0 ? r : -r, i = i < 0 ? i : -i, e2 = e.sub(e.rotWith(e2, t, -u), t), n = e.sub(e.rotWith(n, t, -u), t);
  let s = e.sub(n, e2), o = s[0] * s[0] / r / r + s[1] * s[1] / i / i, c = 2 * e2[0] * s[0] / r / r + 2 * e2[1] * s[1] / i / i, m = e2[0] * e2[0] / r / r + e2[1] * e2[1] / i / i - 1, b = [], f = c * c - 4 * o * m;
  if (f === 0)
    b.push(-c / 2 / o);
  else if (f > 0) {
    let L = Math.sqrt(f);
    b.push((-c + L) / 2 / o), b.push((-c - L) / 2 / o);
  }
  let p = b.filter((L) => L >= 0 && L <= 1).map((L) => e.add(t, e.add(e2, e.mul(e.sub(n, e2), L)))).map((L) => e.rotWith(L, t, u));
  return l("intersection", ...p);
}
function ce(e2, n, t) {
  return z(t, e2, n);
}
function S(e2, n, t) {
  let r = [];
  for (let i = 1; i < t.length; i++) {
    let u = B(e2, n, t[i - 1], t[i]);
    u && r.push(...u.points);
  }
  return r.length === 0 ? l("no intersection") : l("intersection", ...t);
}
function D(e2, n, t) {
  let r = [];
  for (let i = 1; i < t.length + 1; i++) {
    let u = B(e2, n, t[i - 1], t[i % t.length]);
    u && r.push(...u.points);
  }
  return r.length === 0 ? l("no intersection") : l("intersection", ...t);
}
function G(e2, n, t, r, i) {
  return I(e2, n, t).reduce((s, [o, [c, m]]) => {
    let b = x(r, i, c, m);
    return b && s.push(l(o, ...b.points)), s;
  }, []).filter((s) => s.didIntersect);
}
function E(e2, n, t, r) {
  return I(e2, n).reduce((u, [s, [o, c]]) => {
    let m = B(t, r, o, c);
    return m && u.push(l(s, ...m.points)), u;
  }, []).filter((u) => u.didIntersect);
}
function a(e2, n, t, r) {
  return I(e2, n).reduce((u, [s, [o, c]]) => {
    let m = E(t, r, o, c);
    return u.push(...m.map((b) => l(`${s} ${b.message}`, ...b.points))), u;
  }, []).filter((u) => u.didIntersect);
}
function H(e2, n, t, r, i, u) {
  return I(e2, n).reduce((o, [c, [m, b]]) => {
    let f = O(t, r, i, u, m, b);
    return f && o.push(T(g({}, f), { message: c })), o;
  }, []).filter((o) => o.didIntersect);
}
function C(e2, n, t, r) {
  return I(e2, n).reduce((u, [s, [o, c]]) => {
    let m = R(o, c, t, r);
    return m && u.push(T(g({}, m), { message: s })), u;
  }, []).filter((u) => u.didIntersect);
}
function J(e2, n, t, r, i, u = 0) {
  return I(e2, n).reduce((o, [c, [m, b]]) => {
    let f = y(m, b, t, r, i, u);
    return f && o.push(T(g({}, f), { message: c })), o;
  }, []).filter((o) => o.didIntersect);
}
function me(e2, n, t) {
  let { minX: r, minY: i, width: u, height: s } = t;
  return a(e2, n, [r, i], [u, s]);
}
function w(e2, n, t) {
  return I(e2, n).reduce((i, [u, [s, o]]) => {
    let c = S(s, o, t);
    return c.didIntersect && i.push(l(u, ...c.points)), i;
  }, []).filter((i) => i.didIntersect);
}
function K(e2, n, t) {
  return I(e2, n).reduce((i, [u, [s, o]]) => {
    let c = D(s, o, t);
    return c.didIntersect && i.push(l(u, ...c.points)), i;
  }, []).filter((i) => i.didIntersect);
}
function O(e2, n, t, r, i, u) {
  return k(i, u, e2, n, t, r);
}
function _(e2, n, t, r, i, u) {
  return H(i, u, e2, n, t, r);
}
function be(e2, n, t, r, i) {
  let { minX: u, minY: s, width: o, height: c } = i;
  return _(e2, n, t, r, [u, s], [o, c]);
}
function de(e2, n, t, r) {
  return R(t, r, e2, n);
}
function le(e2, n, t, r) {
  let i = t[0] - e2[0], u = t[1] - e2[1], s = Math.sqrt(i * i + u * u), o = (s * s - r * r + n * n) / (2 * s), c = Math.sqrt(n * n - o * o);
  return i /= s, u /= s, l("intersection", [e2[0] + i * o - u * c, e2[1] + u * o + i * c], [e2[0] + i * o + u * c, e2[1] + u * o - i * c]);
}
function P(e2, n, t, r) {
  return C(t, r, e2, n);
}
function fe(e2, n, t) {
  let { minX: r, minY: i, width: u, height: s } = t;
  return P(e2, n, [r, i], [u, s]);
}
function Le(e2, n, t, r, i, u) {
  return F(i, u, e2, n, t, r);
}
function U(e2, n, t, r = 0, i, u) {
  return n === t ? R(i, u, e2, n) : y(i, u, e2, n, t, r);
}
function W(e2, n, t, r = 0, i, u) {
  return n === t ? C(i, u, e2, n) : J(i, u, e2, n, t, r);
}
function Z(e2, n, t, r, i, u, s, o) {
  return l("no intersection");
}
function Ie(e2, n, t, r, i, u) {
  return Z(e2, n, t, r, i, u, u, 0);
}
function pe(e2, n, t, r, i) {
  let { minX: u, minY: s, width: o, height: c } = i;
  return W(e2, n, t, r, [u, s], [o, c]);
}
function he(e2, n, t) {
  let { minX: r, minY: i, width: u, height: s } = e2;
  return N(n, t, [r, i], [u, s]);
}
function z(e2, n, t) {
  let { minX: r, minY: i, width: u, height: s } = e2;
  return j(n, t, [r, i], [u, s]);
}
function ge(e2, n, t) {
  let { minX: r, minY: i, width: u, height: s } = e2;
  return a(n, t, [r, i], [u, s]);
}
function Te(e2, n) {
  return a([e2.minX, e2.minY], [e2.width, e2.height], [n.minX, n.minY], [n.width, n.height]);
}
function xe(e2, n, t, r, i) {
  let { minX: u, minY: s, width: o, height: c } = e2;
  return _(n, t, r, i, [u, s], [o, c]);
}
function Be(e2, n, t) {
  let { minX: r, minY: i, width: u, height: s } = e2;
  return P(n, t, [r, i], [u, s]);
}
function Re(e2, n, t, r, i = 0) {
  let { minX: u, minY: s, width: o, height: c } = e2;
  return W(n, t, r, i, [u, s], [o, c]);
}
function ye(e2, n) {
  return Q(n, e2);
}
function Se(e2, n) {
  return ee(n, e2);
}
function ae(e2, n, t) {
  return S(n, t, e2);
}
function we(e2, n, t) {
  return w(n, t, e2);
}
function Q(e2, n) {
  return w([n.minX, n.minY], [n.width, n.height], e2);
}
function Xe(e2, n, t) {
  return S(n, t, e2);
}
function Ye(e2, n, t) {
  return w(n, t, e2);
}
function ee(e2, n) {
  return K([n.minX, n.minY], [n.width, n.height], e2);
}
function Ne(e2, n, t) {
  return ne(t, true).reduce((i, [u, s], o) => {
    let c = x(e2, n, u, s);
    return c && i.push(l(o.toString(), ...c.points)), i;
  }, []).filter((i) => i.didIntersect);
}
function ne(e2, n = false) {
  let t = [];
  for (let r = 1; r < e2.length; r++)
    t.push([e2[r - 1], e2[r]]);
  return n && t.push([e2[e2.length - 1], e2[0]]), t;
}
export {
  be as intersectArcBounds,
  O as intersectArcLineSegment,
  _ as intersectArcRectangle,
  xe as intersectBoundsArc,
  Te as intersectBoundsBounds,
  Be as intersectBoundsCircle,
  Re as intersectBoundsEllipse,
  z as intersectBoundsLineSegment,
  Se as intersectBoundsPolygon,
  ye as intersectBoundsPolyline,
  he as intersectBoundsRay,
  ge as intersectBoundsRectangle,
  fe as intersectCircleBounds,
  le as intersectCircleCircle,
  de as intersectCircleLineSegment,
  P as intersectCircleRectangle,
  pe as intersectEllipseBounds,
  Ie as intersectEllipseCircle,
  Z as intersectEllipseEllipse,
  U as intersectEllipseLineSegment,
  Le as intersectEllipseRay,
  W as intersectEllipseRectangle,
  ie as intersectLineLine,
  k as intersectLineSegmentArc,
  ce as intersectLineSegmentBounds,
  R as intersectLineSegmentCircle,
  y as intersectLineSegmentEllipse,
  B as intersectLineSegmentLineSegment,
  D as intersectLineSegmentPolygon,
  S as intersectLineSegmentPolyline,
  oe as intersectLineSegmentRay,
  j as intersectLineSegmentRectangle,
  ee as intersectPolygonBounds,
  Xe as intersectPolygonLineSegment,
  Ye as intersectPolygonRectangle,
  Q as intersectPolylineBounds,
  ae as intersectPolylineLineSegment,
  we as intersectPolylineRectangle,
  se as intersectRayBounds,
  F as intersectRayEllipse,
  x as intersectRayLineSegment,
  Ne as intersectRayPolygon,
  ue as intersectRayRay,
  N as intersectRayRectangle,
  H as intersectRectangleArc,
  me as intersectRectangleBounds,
  C as intersectRectangleCircle,
  J as intersectRectangleEllipse,
  E as intersectRectangleLineSegment,
  K as intersectRectanglePolygon,
  w as intersectRectanglePolyline,
  G as intersectRectangleRay,
  a as intersectRectangleRectangle,
  ne as pointsToLineSegments
};
//# sourceMappingURL=@tldraw_intersect.js.map
