import {
  _e
} from "./chunk-MHTOP6FF.js";
import {
  require_react
} from "./chunk-S4LFUXEE.js";
import {
  ee
} from "./chunk-U5ZZSG6H.js";
import {
  e
} from "./chunk-ATHO37WQ.js";
import {
  __toESM
} from "./chunk-TWLJ45QX.js";

// node_modules/@tldraw/core/dist/index.mjs
var React45 = __toESM(require_react(), 1);
var React44 = __toESM(require_react(), 1);
var React17 = __toESM(require_react(), 1);
var React16 = __toESM(require_react(), 1);
var React2 = __toESM(require_react(), 1);

// node_modules/@use-gesture/core/dist/maths-b28d9b98.esm.js
function clamp(v, min, max) {
  return Math.max(min, Math.min(v, max));
}
var V = {
  toVector(v, fallback) {
    if (v === void 0)
      v = fallback;
    return Array.isArray(v) ? v : [v, v];
  },
  add(v1, v2) {
    return [v1[0] + v2[0], v1[1] + v2[1]];
  },
  sub(v1, v2) {
    return [v1[0] - v2[0], v1[1] - v2[1]];
  },
  addTo(v1, v2) {
    v1[0] += v2[0];
    v1[1] += v2[1];
  },
  subTo(v1, v2) {
    v1[0] -= v2[0];
    v1[1] -= v2[1];
  }
};
function rubberband(distance, dimension, constant) {
  if (dimension === 0 || Math.abs(dimension) === Infinity)
    return Math.pow(distance, constant * 5);
  return distance * dimension * constant / (dimension + constant * distance);
}
function rubberbandIfOutOfBounds(position, min, max, constant = 0.15) {
  if (constant === 0)
    return clamp(position, min, max);
  if (position < min)
    return -rubberband(min - position, max - min, constant) + min;
  if (position > max)
    return +rubberband(position - max, max - min, constant) + max;
  return position;
}
function computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {
  const [[X0, X1], [Y0, Y1]] = bounds;
  return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];
}

// node_modules/@use-gesture/core/dist/actions-e3d93fde.esm.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var EVENT_TYPE_MAP = {
  pointer: {
    start: "down",
    change: "move",
    end: "up"
  },
  mouse: {
    start: "down",
    change: "move",
    end: "up"
  },
  touch: {
    start: "start",
    change: "move",
    end: "end"
  },
  gesture: {
    start: "start",
    change: "change",
    end: "end"
  }
};
function capitalize(string) {
  if (!string)
    return "";
  return string[0].toUpperCase() + string.slice(1);
}
var actionsWithoutCaptureSupported = ["enter", "leave"];
function hasCapture(capture = false, actionKey) {
  return capture && !actionsWithoutCaptureSupported.includes(actionKey);
}
function toHandlerProp(device, action = "", capture = false) {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action] || action : action;
  return "on" + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? "Capture" : "");
}
var pointerCaptureEvents = ["gotpointercapture", "lostpointercapture"];
function parseProp(prop) {
  let eventKey = prop.substring(2).toLowerCase();
  const passive = !!~eventKey.indexOf("passive");
  if (passive)
    eventKey = eventKey.replace("passive", "");
  const captureKey = pointerCaptureEvents.includes(eventKey) ? "capturecapture" : "capture";
  const capture = !!~eventKey.indexOf(captureKey);
  if (capture)
    eventKey = eventKey.replace("capture", "");
  return {
    device: eventKey,
    capture,
    passive
  };
}
function toDomEventType(device, action = "") {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action] || action : action;
  return device + actionKey;
}
function isTouch(event) {
  return "touches" in event;
}
function getPointerType(event) {
  if (isTouch(event))
    return "touch";
  if ("pointerType" in event)
    return event.pointerType;
  return "mouse";
}
function getCurrentTargetTouchList(event) {
  return Array.from(event.touches).filter((e2) => {
    var _event$currentTarget, _event$currentTarget$;
    return e2.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 ? void 0 : (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e2.target));
  });
}
function getTouchList(event) {
  return event.type === "touchend" || event.type === "touchcancel" ? event.changedTouches : event.targetTouches;
}
function getValueEvent(event) {
  return isTouch(event) ? getTouchList(event)[0] : event;
}
function distanceAngle(P1, P2) {
  const dx = P2.clientX - P1.clientX;
  const dy = P2.clientY - P1.clientY;
  const cx = (P2.clientX + P1.clientX) / 2;
  const cy = (P2.clientY + P1.clientY) / 2;
  const distance = Math.hypot(dx, dy);
  const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;
  const origin = [cx, cy];
  return {
    angle,
    distance,
    origin
  };
}
function touchIds(event) {
  return getCurrentTargetTouchList(event).map((touch) => touch.identifier);
}
function touchDistanceAngle(event, ids) {
  const [P1, P2] = Array.from(event.touches).filter((touch) => ids.includes(touch.identifier));
  return distanceAngle(P1, P2);
}
function pointerId(event) {
  const valueEvent = getValueEvent(event);
  return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;
}
function pointerValues(event) {
  const valueEvent = getValueEvent(event);
  return [valueEvent.clientX, valueEvent.clientY];
}
var LINE_HEIGHT = 40;
var PAGE_HEIGHT = 800;
function wheelValues(event) {
  let {
    deltaX,
    deltaY,
    deltaMode
  } = event;
  if (deltaMode === 1) {
    deltaX *= LINE_HEIGHT;
    deltaY *= LINE_HEIGHT;
  } else if (deltaMode === 2) {
    deltaX *= PAGE_HEIGHT;
    deltaY *= PAGE_HEIGHT;
  }
  return [deltaX, deltaY];
}
function scrollValues(event) {
  var _ref, _ref2;
  const {
    scrollX,
    scrollY,
    scrollLeft,
    scrollTop
  } = event.currentTarget;
  return [(_ref = scrollX !== null && scrollX !== void 0 ? scrollX : scrollLeft) !== null && _ref !== void 0 ? _ref : 0, (_ref2 = scrollY !== null && scrollY !== void 0 ? scrollY : scrollTop) !== null && _ref2 !== void 0 ? _ref2 : 0];
}
function getEventDetails(event) {
  const payload = {};
  if ("buttons" in event)
    payload.buttons = event.buttons;
  if ("shiftKey" in event) {
    const {
      shiftKey,
      altKey,
      metaKey,
      ctrlKey
    } = event;
    Object.assign(payload, {
      shiftKey,
      altKey,
      metaKey,
      ctrlKey
    });
  }
  return payload;
}
function call(v, ...args) {
  if (typeof v === "function") {
    return v(...args);
  } else {
    return v;
  }
}
function noop() {
}
function chain(...fns) {
  if (fns.length === 0)
    return noop;
  if (fns.length === 1)
    return fns[0];
  return function() {
    let result;
    for (const fn of fns) {
      result = fn.apply(this, arguments) || result;
    }
    return result;
  };
}
function assignDefault(value, fallback) {
  return Object.assign({}, fallback, value || {});
}
var BEFORE_LAST_KINEMATICS_DELAY = 32;
var Engine = class {
  constructor(ctrl, args, key) {
    this.ctrl = ctrl;
    this.args = args;
    this.key = key;
    if (!this.state) {
      this.state = {};
      this.computeValues([0, 0]);
      this.computeInitial();
      if (this.init)
        this.init();
      this.reset();
    }
  }
  get state() {
    return this.ctrl.state[this.key];
  }
  set state(state) {
    this.ctrl.state[this.key] = state;
  }
  get shared() {
    return this.ctrl.state.shared;
  }
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key];
  }
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key];
  }
  get config() {
    return this.ctrl.config[this.key];
  }
  get sharedConfig() {
    return this.ctrl.config.shared;
  }
  get handler() {
    return this.ctrl.handlers[this.key];
  }
  reset() {
    const {
      state,
      shared,
      ingKey,
      args
    } = this;
    shared[ingKey] = state._active = state.active = state._blocked = state._force = false;
    state._step = [false, false];
    state.intentional = false;
    state._movement = [0, 0];
    state._distance = [0, 0];
    state._direction = [0, 0];
    state._delta = [0, 0];
    state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];
    state.args = args;
    state.axis = void 0;
    state.memo = void 0;
    state.elapsedTime = 0;
    state.direction = [0, 0];
    state.distance = [0, 0];
    state.overflow = [0, 0];
    state._movementBound = [false, false];
    state.velocity = [0, 0];
    state.movement = [0, 0];
    state.delta = [0, 0];
    state.timeStamp = 0;
  }
  start(event) {
    const state = this.state;
    const config = this.config;
    if (!state._active) {
      this.reset();
      this.computeInitial();
      state._active = true;
      state.target = event.target;
      state.currentTarget = event.currentTarget;
      state.lastOffset = config.from ? call(config.from, state) : state.offset;
      state.offset = state.lastOffset;
    }
    state.startTime = state.timeStamp = event.timeStamp;
  }
  computeValues(values) {
    const state = this.state;
    state._values = values;
    state.values = this.config.transform(values);
  }
  computeInitial() {
    const state = this.state;
    state._initial = state._values;
    state.initial = state.values;
  }
  compute(event) {
    const {
      state,
      config,
      shared
    } = this;
    state.args = this.args;
    let dt = 0;
    if (event) {
      state.event = event;
      if (config.preventDefault && event.cancelable)
        state.event.preventDefault();
      state.type = event.type;
      shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;
      shared.locked = !!document.pointerLockElement;
      Object.assign(shared, getEventDetails(event));
      shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;
      dt = event.timeStamp - state.timeStamp;
      state.timeStamp = event.timeStamp;
      state.elapsedTime = state.timeStamp - state.startTime;
    }
    if (state._active) {
      const _absoluteDelta = state._delta.map(Math.abs);
      V.addTo(state._distance, _absoluteDelta);
    }
    if (this.axisIntent)
      this.axisIntent(event);
    const [_m0, _m1] = state._movement;
    const [t0, t1] = config.threshold;
    const {
      _step,
      values
    } = state;
    if (config.hasCustomTransform) {
      if (_step[0] === false)
        _step[0] = Math.abs(_m0) >= t0 && values[0];
      if (_step[1] === false)
        _step[1] = Math.abs(_m1) >= t1 && values[1];
    } else {
      if (_step[0] === false)
        _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;
      if (_step[1] === false)
        _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;
    }
    state.intentional = _step[0] !== false || _step[1] !== false;
    if (!state.intentional)
      return;
    const movement = [0, 0];
    if (config.hasCustomTransform) {
      const [v0, v1] = values;
      movement[0] = _step[0] !== false ? v0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? v1 - _step[1] : 0;
    } else {
      movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;
    }
    if (this.restrictToAxis && !state._blocked)
      this.restrictToAxis(movement);
    const previousOffset = state.offset;
    const gestureIsActive = state._active && !state._blocked || state.active;
    if (gestureIsActive) {
      state.first = state._active && !state.active;
      state.last = !state._active && state.active;
      state.active = shared[this.ingKey] = state._active;
      if (event) {
        if (state.first) {
          if ("bounds" in config)
            state._bounds = call(config.bounds, state);
          if (this.setup)
            this.setup();
        }
        state.movement = movement;
        this.computeOffset();
      }
    }
    const [ox, oy] = state.offset;
    const [[x0, x1], [y0, y1]] = state._bounds;
    state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];
    state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;
    state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;
    const rubberband2 = state._active ? config.rubberband || [0, 0] : [0, 0];
    state.offset = computeRubberband(state._bounds, state.offset, rubberband2);
    state.delta = V.sub(state.offset, previousOffset);
    this.computeMovement();
    if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {
      state.delta = V.sub(state.offset, previousOffset);
      const absoluteDelta = state.delta.map(Math.abs);
      V.addTo(state.distance, absoluteDelta);
      state.direction = state.delta.map(Math.sign);
      state._direction = state._delta.map(Math.sign);
      if (!state.first && dt > 0) {
        state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];
      }
    }
  }
  emit() {
    const state = this.state;
    const shared = this.shared;
    const config = this.config;
    if (!state._active)
      this.clean();
    if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents)
      return;
    const memo27 = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, {
      [this.aliasKey]: state.values
    }));
    if (memo27 !== void 0)
      state.memo = memo27;
  }
  clean() {
    this.eventStore.clean();
    this.timeoutStore.clean();
  }
};
function selectAxis([dx, dy], threshold) {
  const absDx = Math.abs(dx);
  const absDy = Math.abs(dy);
  if (absDx > absDy && absDx > threshold) {
    return "x";
  }
  if (absDy > absDx && absDy > threshold) {
    return "y";
  }
  return void 0;
}
var CoordinatesEngine = class extends Engine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "aliasKey", "xy");
  }
  reset() {
    super.reset();
    this.state.axis = void 0;
  }
  init() {
    this.state.offset = [0, 0];
    this.state.lastOffset = [0, 0];
  }
  computeOffset() {
    this.state.offset = V.add(this.state.lastOffset, this.state.movement);
  }
  computeMovement() {
    this.state.movement = V.sub(this.state.offset, this.state.lastOffset);
  }
  axisIntent(event) {
    const state = this.state;
    const config = this.config;
    if (!state.axis && event) {
      const threshold = typeof config.axisThreshold === "object" ? config.axisThreshold[getPointerType(event)] : config.axisThreshold;
      state.axis = selectAxis(state._movement, threshold);
    }
    state._blocked = (config.lockDirection || !!config.axis) && !state.axis || !!config.axis && config.axis !== state.axis;
  }
  restrictToAxis(v) {
    if (this.config.axis || this.config.lockDirection) {
      switch (this.state.axis) {
        case "x":
          v[1] = 0;
          break;
        case "y":
          v[0] = 0;
          break;
      }
    }
  }
};
var identity = (v) => v;
var DEFAULT_RUBBERBAND = 0.15;
var commonConfigResolver = {
  enabled(value = true) {
    return value;
  },
  eventOptions(value, _k, config) {
    return _objectSpread2(_objectSpread2({}, config.shared.eventOptions), value);
  },
  preventDefault(value = false) {
    return value;
  },
  triggerAllEvents(value = false) {
    return value;
  },
  rubberband(value = 0) {
    switch (value) {
      case true:
        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];
      case false:
        return [0, 0];
      default:
        return V.toVector(value);
    }
  },
  from(value) {
    if (typeof value === "function")
      return value;
    if (value != null)
      return V.toVector(value);
  },
  transform(value, _k, config) {
    const transform = value || config.shared.transform;
    this.hasCustomTransform = !!transform;
    if (true) {
      const originalTransform = transform || identity;
      return (v) => {
        const r = originalTransform(v);
        if (!isFinite(r[0]) || !isFinite(r[1])) {
          console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${r[0]},${[1]}]`);
        }
        return r;
      };
    }
    return transform || identity;
  },
  threshold(value) {
    return V.toVector(value, 0);
  }
};
if (true) {
  Object.assign(commonConfigResolver, {
    domTarget(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
      }
      return NaN;
    },
    lockDirection(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`lockDirection\` option has been merged with \`axis\`. Use it as in \`{ axis: 'lock' }\``);
      }
      return NaN;
    },
    initial(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`initial\` option has been renamed to \`from\`.`);
      }
      return NaN;
    }
  });
}
var DEFAULT_AXIS_THRESHOLD = 0;
var coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
  axis(_v, _k, {
    axis
  }) {
    this.lockDirection = axis === "lock";
    if (!this.lockDirection)
      return axis;
  },
  axisThreshold(value = DEFAULT_AXIS_THRESHOLD) {
    return value;
  },
  bounds(value = {}) {
    if (typeof value === "function") {
      return (state) => coordinatesConfigResolver.bounds(value(state));
    }
    if ("current" in value) {
      return () => value.current;
    }
    if (typeof HTMLElement === "function" && value instanceof HTMLElement) {
      return value;
    }
    const {
      left = -Infinity,
      right = Infinity,
      top = -Infinity,
      bottom = Infinity
    } = value;
    return [[left, right], [top, bottom]];
  }
});
var DISPLACEMENT = 10;
var KEYS_DELTA_MAP = {
  ArrowRight: (factor = 1) => [DISPLACEMENT * factor, 0],
  ArrowLeft: (factor = 1) => [-DISPLACEMENT * factor, 0],
  ArrowUp: (factor = 1) => [0, -DISPLACEMENT * factor],
  ArrowDown: (factor = 1) => [0, DISPLACEMENT * factor]
};
var DragEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "dragging");
  }
  reset() {
    super.reset();
    const state = this.state;
    state._pointerId = void 0;
    state._pointerActive = false;
    state._keyboardActive = false;
    state._preventScroll = false;
    state._delayed = false;
    state.swipe = [0, 0];
    state.tap = false;
    state.canceled = false;
    state.cancel = this.cancel.bind(this);
  }
  setup() {
    const state = this.state;
    if (state._bounds instanceof HTMLElement) {
      const boundRect = state._bounds.getBoundingClientRect();
      const targetRect = state.currentTarget.getBoundingClientRect();
      const _bounds = {
        left: boundRect.left - targetRect.left + state.offset[0],
        right: boundRect.right - targetRect.right + state.offset[0],
        top: boundRect.top - targetRect.top + state.offset[1],
        bottom: boundRect.bottom - targetRect.bottom + state.offset[1]
      };
      state._bounds = coordinatesConfigResolver.bounds(_bounds);
    }
  }
  cancel() {
    const state = this.state;
    if (state.canceled)
      return;
    state.canceled = true;
    state._active = false;
    setTimeout(() => {
      this.compute();
      this.emit();
    }, 0);
  }
  setActive() {
    this.state._active = this.state._pointerActive || this.state._keyboardActive;
  }
  clean() {
    this.pointerClean();
    this.state._pointerActive = false;
    this.state._keyboardActive = false;
    super.clean();
  }
  pointerDown(event) {
    const config = this.config;
    const state = this.state;
    if (event.buttons != null && (Array.isArray(config.pointerButtons) ? !config.pointerButtons.includes(event.buttons) : config.pointerButtons !== -1 && config.pointerButtons !== event.buttons))
      return;
    const ctrlIds = this.ctrl.setEventIds(event);
    if (config.pointerCapture) {
      event.target.setPointerCapture(event.pointerId);
    }
    if (ctrlIds && ctrlIds.size > 1 && state._pointerActive)
      return;
    this.start(event);
    this.setupPointer(event);
    state._pointerId = pointerId(event);
    state._pointerActive = true;
    this.computeValues(pointerValues(event));
    this.computeInitial();
    if (config.preventScrollAxis && getPointerType(event) !== "mouse") {
      state._active = false;
      this.setupScrollPrevention(event);
    } else if (config.delay > 0) {
      this.setupDelayTrigger(event);
      if (config.triggerAllEvents) {
        this.compute(event);
        this.emit();
      }
    } else {
      this.startPointerDrag(event);
    }
  }
  startPointerDrag(event) {
    const state = this.state;
    state._active = true;
    state._preventScroll = true;
    state._delayed = false;
    this.compute(event);
    this.emit();
  }
  pointerMove(event) {
    const state = this.state;
    const config = this.config;
    if (!state._pointerActive)
      return;
    if (state.type === event.type && event.timeStamp === state.timeStamp)
      return;
    const id = pointerId(event);
    if (state._pointerId !== void 0 && id !== state._pointerId)
      return;
    const _values = pointerValues(event);
    if (document.pointerLockElement === event.target) {
      state._delta = [event.movementX, event.movementY];
    } else {
      state._delta = V.sub(_values, state._values);
      this.computeValues(_values);
    }
    V.addTo(state._movement, state._delta);
    this.compute(event);
    if (state._delayed && state.intentional) {
      this.timeoutStore.remove("dragDelay");
      state.active = false;
      this.startPointerDrag(event);
      return;
    }
    if (config.preventScrollAxis && !state._preventScroll) {
      if (state.axis) {
        if (state.axis === config.preventScrollAxis || config.preventScrollAxis === "xy") {
          state._active = false;
          this.clean();
          return;
        } else {
          this.timeoutStore.remove("startPointerDrag");
          this.startPointerDrag(event);
          return;
        }
      } else {
        return;
      }
    }
    this.emit();
  }
  pointerUp(event) {
    this.ctrl.setEventIds(event);
    try {
      if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {
        ;
        event.target.releasePointerCapture(event.pointerId);
      }
    } catch (_unused) {
      if (true) {
        console.warn(`[@use-gesture]: If you see this message, it's likely that you're using an outdated version of \`@react-three/fiber\`. 

Please upgrade to the latest version.`);
      }
    }
    const state = this.state;
    const config = this.config;
    if (!state._active || !state._pointerActive)
      return;
    const id = pointerId(event);
    if (state._pointerId !== void 0 && id !== state._pointerId)
      return;
    this.state._pointerActive = false;
    this.setActive();
    this.compute(event);
    const [dx, dy] = state._distance;
    state.tap = dx <= config.tapsThreshold && dy <= config.tapsThreshold;
    if (state.tap && config.filterTaps) {
      state._force = true;
    } else {
      const [dirx, diry] = state.direction;
      const [vx, vy] = state.velocity;
      const [mx, my] = state.movement;
      const [svx, svy] = config.swipe.velocity;
      const [sx, sy] = config.swipe.distance;
      const sdt = config.swipe.duration;
      if (state.elapsedTime < sdt) {
        if (Math.abs(vx) > svx && Math.abs(mx) > sx)
          state.swipe[0] = dirx;
        if (Math.abs(vy) > svy && Math.abs(my) > sy)
          state.swipe[1] = diry;
      }
    }
    this.emit();
  }
  pointerClick(event) {
    if (!this.state.tap && event.detail > 0) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  setupPointer(event) {
    const config = this.config;
    const device = config.device;
    if (true) {
      try {
        if (device === "pointer" && config.preventScrollDelay === void 0) {
          const currentTarget = "uv" in event ? event.sourceEvent.currentTarget : event.currentTarget;
          const style = window.getComputedStyle(currentTarget);
          if (style.touchAction === "auto") {
            console.warn(`[@use-gesture]: The drag target has its \`touch-action\` style property set to \`auto\`. It is recommended to add \`touch-action: 'none'\` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.

This message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.`, currentTarget);
          }
        }
      } catch (_unused2) {
      }
    }
    if (config.pointerLock) {
      event.currentTarget.requestPointerLock();
    }
    if (!config.pointerCapture) {
      this.eventStore.add(this.sharedConfig.window, device, "change", this.pointerMove.bind(this));
      this.eventStore.add(this.sharedConfig.window, device, "end", this.pointerUp.bind(this));
      this.eventStore.add(this.sharedConfig.window, device, "cancel", this.pointerUp.bind(this));
    }
  }
  pointerClean() {
    if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {
      document.exitPointerLock();
    }
  }
  preventScroll(event) {
    if (this.state._preventScroll && event.cancelable) {
      event.preventDefault();
    }
  }
  setupScrollPrevention(event) {
    this.state._preventScroll = false;
    persistEvent(event);
    const remove = this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
      passive: false
    });
    this.eventStore.add(this.sharedConfig.window, "touch", "end", remove);
    this.eventStore.add(this.sharedConfig.window, "touch", "cancel", remove);
    this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScrollDelay, event);
  }
  setupDelayTrigger(event) {
    this.state._delayed = true;
    this.timeoutStore.add("dragDelay", () => {
      this.state._step = [0, 0];
      this.startPointerDrag(event);
    }, this.config.delay);
  }
  keyDown(event) {
    const deltaFn = KEYS_DELTA_MAP[event.key];
    if (deltaFn) {
      const state = this.state;
      const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;
      this.start(event);
      state._delta = deltaFn(factor);
      state._keyboardActive = true;
      V.addTo(state._movement, state._delta);
      this.compute(event);
      this.emit();
    }
  }
  keyUp(event) {
    if (!(event.key in KEYS_DELTA_MAP))
      return;
    this.state._keyboardActive = false;
    this.setActive();
    this.compute(event);
    this.emit();
  }
  bind(bindFunction) {
    const device = this.config.device;
    bindFunction(device, "start", this.pointerDown.bind(this));
    if (this.config.pointerCapture) {
      bindFunction(device, "change", this.pointerMove.bind(this));
      bindFunction(device, "end", this.pointerUp.bind(this));
      bindFunction(device, "cancel", this.pointerUp.bind(this));
      bindFunction("lostPointerCapture", "", this.pointerUp.bind(this));
    }
    if (this.config.keys) {
      bindFunction("key", "down", this.keyDown.bind(this));
      bindFunction("key", "up", this.keyUp.bind(this));
    }
    if (this.config.filterTaps) {
      bindFunction("click", "", this.pointerClick.bind(this), {
        capture: true,
        passive: false
      });
    }
  }
};
function persistEvent(event) {
  "persist" in event && typeof event.persist === "function" && event.persist();
}
var isBrowser = typeof window !== "undefined" && window.document && window.document.createElement;
function supportsTouchEvents() {
  return isBrowser && "ontouchstart" in window;
}
function isTouchScreen() {
  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;
}
function supportsPointerEvents() {
  return isBrowser && "onpointerdown" in window;
}
function supportsPointerLock() {
  return isBrowser && "exitPointerLock" in window.document;
}
function supportsGestureEvents() {
  try {
    return "constructor" in GestureEvent;
  } catch (e2) {
    return false;
  }
}
var SUPPORT = {
  isBrowser,
  gesture: supportsGestureEvents(),
  touch: isTouchScreen(),
  touchscreen: isTouchScreen(),
  pointer: supportsPointerEvents(),
  pointerLock: supportsPointerLock()
};
var DEFAULT_PREVENT_SCROLL_DELAY = 250;
var DEFAULT_DRAG_DELAY = 180;
var DEFAULT_SWIPE_VELOCITY = 0.5;
var DEFAULT_SWIPE_DISTANCE = 50;
var DEFAULT_SWIPE_DURATION = 250;
var DEFAULT_DRAG_AXIS_THRESHOLD = {
  mouse: 0,
  touch: 0,
  pen: 8
};
var dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  device(_v, _k, {
    pointer: {
      touch = false,
      lock = false,
      mouse = false
    } = {}
  }) {
    this.pointerLock = lock && SUPPORT.pointerLock;
    if (SUPPORT.touch && touch)
      return "touch";
    if (this.pointerLock)
      return "mouse";
    if (SUPPORT.pointer && !mouse)
      return "pointer";
    if (SUPPORT.touch)
      return "touch";
    return "mouse";
  },
  preventScrollAxis(value, _k, {
    preventScroll
  }) {
    this.preventScrollDelay = typeof preventScroll === "number" ? preventScroll : preventScroll || preventScroll === void 0 && value ? DEFAULT_PREVENT_SCROLL_DELAY : void 0;
    if (!SUPPORT.touchscreen || preventScroll === false)
      return void 0;
    return value ? value : preventScroll !== void 0 ? "y" : void 0;
  },
  pointerCapture(_v, _k, {
    pointer: {
      capture = true,
      buttons = 1,
      keys = true
    } = {}
  }) {
    this.pointerButtons = buttons;
    this.keys = keys;
    return !this.pointerLock && this.device === "pointer" && capture;
  },
  threshold(value, _k, {
    filterTaps = false,
    tapsThreshold = 3,
    axis = void 0
  }) {
    const threshold = V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);
    this.filterTaps = filterTaps;
    this.tapsThreshold = tapsThreshold;
    return threshold;
  },
  swipe({
    velocity = DEFAULT_SWIPE_VELOCITY,
    distance = DEFAULT_SWIPE_DISTANCE,
    duration = DEFAULT_SWIPE_DURATION
  } = {}) {
    return {
      velocity: this.transform(V.toVector(velocity)),
      distance: this.transform(V.toVector(distance)),
      duration
    };
  },
  delay(value = 0) {
    switch (value) {
      case true:
        return DEFAULT_DRAG_DELAY;
      case false:
        return 0;
      default:
        return value;
    }
  },
  axisThreshold(value) {
    if (!value)
      return DEFAULT_DRAG_AXIS_THRESHOLD;
    return _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);
  }
});
if (true) {
  Object.assign(dragConfigResolver, {
    useTouch(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`useTouch\` option has been renamed to \`pointer.touch\`. Use it as in \`{ pointer: { touch: true } }\`.`);
      }
      return NaN;
    },
    experimental_preventWindowScrollY(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`experimental_preventWindowScrollY\` option has been renamed to \`preventScroll\`.`);
      }
      return NaN;
    },
    swipeVelocity(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeVelocity\` option has been renamed to \`swipe.velocity\`. Use it as in \`{ swipe: { velocity: 0.5 } }\`.`);
      }
      return NaN;
    },
    swipeDistance(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeDistance\` option has been renamed to \`swipe.distance\`. Use it as in \`{ swipe: { distance: 50 } }\`.`);
      }
      return NaN;
    },
    swipeDuration(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeDuration\` option has been renamed to \`swipe.duration\`. Use it as in \`{ swipe: { duration: 250 } }\`.`);
      }
      return NaN;
    }
  });
}
function clampStateInternalMovementToBounds(state) {
  const [ox, oy] = state.overflow;
  const [dx, dy] = state._delta;
  const [dirx, diry] = state._direction;
  if (ox < 0 && dx > 0 && dirx < 0 || ox > 0 && dx < 0 && dirx > 0) {
    state._movement[0] = state._movementBound[0];
  }
  if (oy < 0 && dy > 0 && diry < 0 || oy > 0 && dy < 0 && diry > 0) {
    state._movement[1] = state._movementBound[1];
  }
}
var SCALE_ANGLE_RATIO_INTENT_DEG = 30;
var PINCH_WHEEL_RATIO = 100;
var PinchEngine = class extends Engine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "pinching");
    _defineProperty(this, "aliasKey", "da");
  }
  init() {
    this.state.offset = [1, 0];
    this.state.lastOffset = [1, 0];
    this.state._pointerEvents = /* @__PURE__ */ new Map();
  }
  reset() {
    super.reset();
    const state = this.state;
    state._touchIds = [];
    state.canceled = false;
    state.cancel = this.cancel.bind(this);
    state.turns = 0;
  }
  computeOffset() {
    const {
      type,
      movement,
      lastOffset
    } = this.state;
    if (type === "wheel") {
      this.state.offset = V.add(movement, lastOffset);
    } else {
      this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];
    }
  }
  computeMovement() {
    const {
      offset,
      lastOffset
    } = this.state;
    this.state.movement = [offset[0] / lastOffset[0], offset[1] - lastOffset[1]];
  }
  axisIntent() {
    const state = this.state;
    const [_m0, _m1] = state._movement;
    if (!state.axis) {
      const axisMovementDifference = Math.abs(_m0) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(_m1);
      if (axisMovementDifference < 0)
        state.axis = "angle";
      else if (axisMovementDifference > 0)
        state.axis = "scale";
    }
  }
  restrictToAxis(v) {
    if (this.config.lockDirection) {
      if (this.state.axis === "scale")
        v[1] = 0;
      else if (this.state.axis === "angle")
        v[0] = 0;
    }
  }
  cancel() {
    const state = this.state;
    if (state.canceled)
      return;
    setTimeout(() => {
      state.canceled = true;
      state._active = false;
      this.compute();
      this.emit();
    }, 0);
  }
  touchStart(event) {
    this.ctrl.setEventIds(event);
    const state = this.state;
    const ctrlTouchIds = this.ctrl.touchIds;
    if (state._active) {
      if (state._touchIds.every((id) => ctrlTouchIds.has(id)))
        return;
    }
    if (ctrlTouchIds.size < 2)
      return;
    this.start(event);
    state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);
    const payload = touchDistanceAngle(event, state._touchIds);
    this.pinchStart(event, payload);
  }
  pointerStart(event) {
    if (event.buttons != null && event.buttons % 2 !== 1)
      return;
    this.ctrl.setEventIds(event);
    event.target.setPointerCapture(event.pointerId);
    const state = this.state;
    const _pointerEvents = state._pointerEvents;
    const ctrlPointerIds = this.ctrl.pointerIds;
    if (state._active) {
      if (Array.from(_pointerEvents.keys()).every((id) => ctrlPointerIds.has(id)))
        return;
    }
    if (_pointerEvents.size < 2) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (state._pointerEvents.size < 2)
      return;
    this.start(event);
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    this.pinchStart(event, payload);
  }
  pinchStart(event, payload) {
    const state = this.state;
    state.origin = payload.origin;
    this.computeValues([payload.distance, payload.angle]);
    this.computeInitial();
    this.compute(event);
    this.emit();
  }
  touchMove(event) {
    if (!this.state._active)
      return;
    const payload = touchDistanceAngle(event, this.state._touchIds);
    this.pinchMove(event, payload);
  }
  pointerMove(event) {
    const _pointerEvents = this.state._pointerEvents;
    if (_pointerEvents.has(event.pointerId)) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (!this.state._active)
      return;
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    this.pinchMove(event, payload);
  }
  pinchMove(event, payload) {
    const state = this.state;
    const prev_a = state._values[1];
    const delta_a = payload.angle - prev_a;
    let delta_turns = 0;
    if (Math.abs(delta_a) > 270)
      delta_turns += Math.sign(delta_a);
    this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);
    state.origin = payload.origin;
    state.turns = delta_turns;
    state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];
    this.compute(event);
    this.emit();
  }
  touchEnd(event) {
    this.ctrl.setEventIds(event);
    if (!this.state._active)
      return;
    if (this.state._touchIds.some((id) => !this.ctrl.touchIds.has(id))) {
      this.state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  pointerEnd(event) {
    const state = this.state;
    this.ctrl.setEventIds(event);
    try {
      event.target.releasePointerCapture(event.pointerId);
    } catch (_unused) {
    }
    if (state._pointerEvents.has(event.pointerId)) {
      state._pointerEvents.delete(event.pointerId);
    }
    if (!state._active)
      return;
    if (state._pointerEvents.size < 2) {
      state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  gestureStart(event) {
    if (event.cancelable)
      event.preventDefault();
    const state = this.state;
    if (state._active)
      return;
    this.start(event);
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  gestureMove(event) {
    if (event.cancelable)
      event.preventDefault();
    if (!this.state._active)
      return;
    const state = this.state;
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    const _previousMovement = state._movement;
    state._movement = [event.scale - 1, event.rotation];
    state._delta = V.sub(state._movement, _previousMovement);
    this.compute(event);
    this.emit();
  }
  gestureEnd(event) {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute(event);
    this.emit();
  }
  wheel(event) {
    const modifierKey = this.config.modifierKey;
    if (modifierKey && !event[modifierKey])
      return;
    if (!this.state._active)
      this.wheelStart(event);
    else
      this.wheelChange(event);
    this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelStart(event) {
    this.start(event);
    this.wheelChange(event);
  }
  wheelChange(event) {
    const isR3f = "uv" in event;
    if (!isR3f) {
      if (event.cancelable) {
        event.preventDefault();
      }
      if (!event.defaultPrevented) {
        console.warn(`[@use-gesture]: To properly support zoom on trackpads, try using the \`target\` option.

This message will only appear in development mode.`);
      }
    }
    const state = this.state;
    state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];
    V.addTo(state._movement, state._delta);
    clampStateInternalMovementToBounds(state);
    this.state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    const device = this.config.device;
    if (!!device) {
      bindFunction(device, "start", this[device + "Start"].bind(this));
      bindFunction(device, "change", this[device + "Move"].bind(this));
      bindFunction(device, "end", this[device + "End"].bind(this));
      bindFunction(device, "cancel", this[device + "End"].bind(this));
    }
    if (this.config.pinchOnWheel) {
      bindFunction("wheel", "", this.wheel.bind(this), {
        passive: false
      });
    }
  }
};
var pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
  device(_v, _k, {
    shared,
    pointer: {
      touch = false
    } = {}
  }) {
    const sharedConfig = shared;
    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture)
      return "gesture";
    if (SUPPORT.touch && touch)
      return "touch";
    if (SUPPORT.touchscreen) {
      if (SUPPORT.pointer)
        return "pointer";
      if (SUPPORT.touch)
        return "touch";
    }
  },
  bounds(_v, _k, {
    scaleBounds = {},
    angleBounds = {}
  }) {
    const _scaleBounds = (state) => {
      const D = assignDefault(call(scaleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [D.min, D.max];
    };
    const _angleBounds = (state) => {
      const A = assignDefault(call(angleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [A.min, A.max];
    };
    if (typeof scaleBounds !== "function" && typeof angleBounds !== "function")
      return [_scaleBounds(), _angleBounds()];
    return (state) => [_scaleBounds(state), _angleBounds(state)];
  },
  threshold(value, _k, config) {
    this.lockDirection = config.axis === "lock";
    const threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0);
    return threshold;
  },
  modifierKey(value) {
    if (value === void 0)
      return "ctrlKey";
    return value;
  },
  pinchOnWheel(value = true) {
    return value;
  }
});
var MoveEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "moving");
  }
  move(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse")
      return;
    if (!this.state._active)
      this.moveStart(event);
    else
      this.moveChange(event);
    this.timeoutStore.add("moveEnd", this.moveEnd.bind(this));
  }
  moveStart(event) {
    this.start(event);
    this.computeValues(pointerValues(event));
    this.compute(event);
    this.computeInitial();
    this.emit();
  }
  moveChange(event) {
    if (!this.state._active)
      return;
    const values = pointerValues(event);
    const state = this.state;
    state._delta = V.sub(values, state._values);
    V.addTo(state._movement, state._delta);
    this.computeValues(values);
    this.compute(event);
    this.emit();
  }
  moveEnd(event) {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute(event);
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("pointer", "change", this.move.bind(this));
    bindFunction("pointer", "leave", this.moveEnd.bind(this));
  }
};
var moveConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  mouseOnly: (value = true) => value
});
var ScrollEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "scrolling");
  }
  scroll(event) {
    if (!this.state._active)
      this.start(event);
    this.scrollChange(event);
    this.timeoutStore.add("scrollEnd", this.scrollEnd.bind(this));
  }
  scrollChange(event) {
    if (event.cancelable)
      event.preventDefault();
    const state = this.state;
    const values = scrollValues(event);
    state._delta = V.sub(values, state._values);
    V.addTo(state._movement, state._delta);
    this.computeValues(values);
    this.compute(event);
    this.emit();
  }
  scrollEnd() {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("scroll", "", this.scroll.bind(this));
  }
};
var scrollConfigResolver = coordinatesConfigResolver;
var WheelEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "wheeling");
  }
  wheel(event) {
    if (!this.state._active)
      this.start(event);
    this.wheelChange(event);
    this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelChange(event) {
    const state = this.state;
    state._delta = wheelValues(event);
    V.addTo(state._movement, state._delta);
    clampStateInternalMovementToBounds(state);
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active)
      return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("wheel", "", this.wheel.bind(this));
  }
};
var wheelConfigResolver = coordinatesConfigResolver;
var HoverEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", "hovering");
  }
  enter(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse")
      return;
    this.start(event);
    this.computeValues(pointerValues(event));
    this.compute(event);
    this.emit();
  }
  leave(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse")
      return;
    const state = this.state;
    if (!state._active)
      return;
    state._active = false;
    const values = pointerValues(event);
    state._movement = state._delta = V.sub(values, state._values);
    this.computeValues(values);
    this.compute(event);
    state.delta = state.movement;
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("pointer", "enter", this.enter.bind(this));
    bindFunction("pointer", "leave", this.leave.bind(this));
  }
};
var hoverConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  mouseOnly: (value = true) => value
});
var EngineMap = /* @__PURE__ */ new Map();
var ConfigResolverMap = /* @__PURE__ */ new Map();
function registerAction(action) {
  EngineMap.set(action.key, action.engine);
  ConfigResolverMap.set(action.key, action.resolver);
}
var dragAction = {
  key: "drag",
  engine: DragEngine,
  resolver: dragConfigResolver
};
var hoverAction = {
  key: "hover",
  engine: HoverEngine,
  resolver: hoverConfigResolver
};
var moveAction = {
  key: "move",
  engine: MoveEngine,
  resolver: moveConfigResolver
};
var pinchAction = {
  key: "pinch",
  engine: PinchEngine,
  resolver: pinchConfigResolver
};
var scrollAction = {
  key: "scroll",
  engine: ScrollEngine,
  resolver: scrollConfigResolver
};
var wheelAction = {
  key: "wheel",
  engine: WheelEngine,
  resolver: wheelConfigResolver
};

// node_modules/@use-gesture/react/dist/use-gesture-react.esm.js
var import_react = __toESM(require_react());

// node_modules/@use-gesture/core/dist/use-gesture-core.esm.js
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
var sharedConfigResolver = {
  target(value) {
    if (value) {
      return () => "current" in value ? value.current : value;
    }
    return void 0;
  },
  enabled(value = true) {
    return value;
  },
  window(value = SUPPORT.isBrowser ? window : void 0) {
    return value;
  },
  eventOptions({
    passive = true,
    capture = false
  } = {}) {
    return {
      passive,
      capture
    };
  },
  transform(value) {
    return value;
  }
};
var _excluded = ["target", "eventOptions", "window", "enabled", "transform"];
function resolveWith(config = {}, resolvers) {
  const result = {};
  for (const [key, resolver] of Object.entries(resolvers)) {
    switch (typeof resolver) {
      case "function":
        if (true) {
          const r = resolver.call(result, config[key], key, config);
          if (!Number.isNaN(r))
            result[key] = r;
        } else {
          result[key] = resolver.call(result, config[key], key, config);
        }
        break;
      case "object":
        result[key] = resolveWith(config[key], resolver);
        break;
      case "boolean":
        if (resolver)
          result[key] = config[key];
        break;
    }
  }
  return result;
}
function parse(newConfig, gestureKey, _config = {}) {
  const _ref = newConfig, {
    target,
    eventOptions,
    window: window2,
    enabled,
    transform
  } = _ref, rest = _objectWithoutProperties(_ref, _excluded);
  _config.shared = resolveWith({
    target,
    eventOptions,
    window: window2,
    enabled,
    transform
  }, sharedConfigResolver);
  if (gestureKey) {
    const resolver = ConfigResolverMap.get(gestureKey);
    _config[gestureKey] = resolveWith(_objectSpread2({
      shared: _config.shared
    }, rest), resolver);
  } else {
    for (const key in rest) {
      const resolver = ConfigResolverMap.get(key);
      if (resolver) {
        _config[key] = resolveWith(_objectSpread2({
          shared: _config.shared
        }, rest[key]), resolver);
      } else if (true) {
        if (!["drag", "pinch", "scroll", "wheel", "move", "hover"].includes(key)) {
          if (key === "domTarget") {
            throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
          }
          console.warn(`[@use-gesture]: Unknown config key \`${key}\` was used. Please read the documentation for further information.`);
        }
      }
    }
  }
  return _config;
}
var EventStore = class {
  constructor(ctrl, gestureKey) {
    _defineProperty(this, "_listeners", /* @__PURE__ */ new Set());
    this._ctrl = ctrl;
    this._gestureKey = gestureKey;
  }
  add(element, device, action, handler, options) {
    const listeners = this._listeners;
    const type = toDomEventType(device, action);
    const _options = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {};
    const eventOptions = _objectSpread2(_objectSpread2({}, _options), options);
    element.addEventListener(type, handler, eventOptions);
    const remove = () => {
      element.removeEventListener(type, handler, eventOptions);
      listeners.delete(remove);
    };
    listeners.add(remove);
    return remove;
  }
  clean() {
    this._listeners.forEach((remove) => remove());
    this._listeners.clear();
  }
};
var TimeoutStore = class {
  constructor() {
    _defineProperty(this, "_timeouts", /* @__PURE__ */ new Map());
  }
  add(key, callback, ms = 140, ...args) {
    this.remove(key);
    this._timeouts.set(key, window.setTimeout(callback, ms, ...args));
  }
  remove(key) {
    const timeout = this._timeouts.get(key);
    if (timeout)
      window.clearTimeout(timeout);
  }
  clean() {
    this._timeouts.forEach((timeout) => void window.clearTimeout(timeout));
    this._timeouts.clear();
  }
};
var Controller = class {
  constructor(handlers) {
    _defineProperty(this, "gestures", /* @__PURE__ */ new Set());
    _defineProperty(this, "_targetEventStore", new EventStore(this));
    _defineProperty(this, "gestureEventStores", {});
    _defineProperty(this, "gestureTimeoutStores", {});
    _defineProperty(this, "handlers", {});
    _defineProperty(this, "config", {});
    _defineProperty(this, "pointerIds", /* @__PURE__ */ new Set());
    _defineProperty(this, "touchIds", /* @__PURE__ */ new Set());
    _defineProperty(this, "state", {
      shared: {
        shiftKey: false,
        metaKey: false,
        ctrlKey: false,
        altKey: false
      }
    });
    resolveGestures(this, handlers);
  }
  setEventIds(event) {
    if (isTouch(event)) {
      this.touchIds = new Set(touchIds(event));
      return this.touchIds;
    } else if ("pointerId" in event) {
      if (event.type === "pointerup" || event.type === "pointercancel")
        this.pointerIds.delete(event.pointerId);
      else if (event.type === "pointerdown")
        this.pointerIds.add(event.pointerId);
      return this.pointerIds;
    }
  }
  applyHandlers(handlers, nativeHandlers) {
    this.handlers = handlers;
    this.nativeHandlers = nativeHandlers;
  }
  applyConfig(config, gestureKey) {
    this.config = parse(config, gestureKey, this.config);
  }
  clean() {
    this._targetEventStore.clean();
    for (const key of this.gestures) {
      this.gestureEventStores[key].clean();
      this.gestureTimeoutStores[key].clean();
    }
  }
  effect() {
    if (this.config.shared.target)
      this.bind();
    return () => this._targetEventStore.clean();
  }
  bind(...args) {
    const sharedConfig = this.config.shared;
    const props = {};
    let target;
    if (sharedConfig.target) {
      target = sharedConfig.target();
      if (!target)
        return;
    }
    if (sharedConfig.enabled) {
      for (const gestureKey of this.gestures) {
        const gestureConfig = this.config[gestureKey];
        const bindFunction = bindToProps(props, gestureConfig.eventOptions, !!target);
        if (gestureConfig.enabled) {
          const Engine2 = EngineMap.get(gestureKey);
          new Engine2(this, args, gestureKey).bind(bindFunction);
        }
      }
      const nativeBindFunction = bindToProps(props, sharedConfig.eventOptions, !!target);
      for (const eventKey in this.nativeHandlers) {
        nativeBindFunction(
          eventKey,
          "",
          (event) => this.nativeHandlers[eventKey](_objectSpread2(_objectSpread2({}, this.state.shared), {}, {
            event,
            args
          })),
          void 0,
          true
        );
      }
    }
    for (const handlerProp in props) {
      props[handlerProp] = chain(...props[handlerProp]);
    }
    if (!target)
      return props;
    for (const handlerProp in props) {
      const {
        device,
        capture,
        passive
      } = parseProp(handlerProp);
      this._targetEventStore.add(target, device, "", props[handlerProp], {
        capture,
        passive
      });
    }
  }
};
function setupGesture(ctrl, gestureKey) {
  ctrl.gestures.add(gestureKey);
  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl, gestureKey);
  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();
}
function resolveGestures(ctrl, internalHandlers) {
  if (internalHandlers.drag)
    setupGesture(ctrl, "drag");
  if (internalHandlers.wheel)
    setupGesture(ctrl, "wheel");
  if (internalHandlers.scroll)
    setupGesture(ctrl, "scroll");
  if (internalHandlers.move)
    setupGesture(ctrl, "move");
  if (internalHandlers.pinch)
    setupGesture(ctrl, "pinch");
  if (internalHandlers.hover)
    setupGesture(ctrl, "hover");
}
var bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options = {}, isNative = false) => {
  var _options$capture, _options$passive;
  const capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;
  const passive = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;
  let handlerProp = isNative ? device : toHandlerProp(device, action, capture);
  if (withPassiveOption && passive)
    handlerProp += "Passive";
  props[handlerProp] = props[handlerProp] || [];
  props[handlerProp].push(handler);
};
var RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;
function sortHandlers(_handlers) {
  const native = {};
  const handlers = {};
  const actions = /* @__PURE__ */ new Set();
  for (let key in _handlers) {
    if (RE_NOT_NATIVE.test(key)) {
      actions.add(RegExp.lastMatch);
      handlers[key] = _handlers[key];
    } else {
      native[key] = _handlers[key];
    }
  }
  return [handlers, native, actions];
}
function registerGesture(actions, handlers, handlerKey, key, internalHandlers, config) {
  if (!actions.has(handlerKey))
    return;
  if (!EngineMap.has(key)) {
    if (true) {
      console.warn(`[@use-gesture]: You've created a custom handler that that uses the \`${key}\` gesture but isn't properly configured.

Please add \`${key}Action\` when creating your handler.`);
    }
    return;
  }
  const startKey = handlerKey + "Start";
  const endKey = handlerKey + "End";
  const fn = (state) => {
    let memo27 = void 0;
    if (state.first && startKey in handlers)
      handlers[startKey](state);
    if (handlerKey in handlers)
      memo27 = handlers[handlerKey](state);
    if (state.last && endKey in handlers)
      handlers[endKey](state);
    return memo27;
  };
  internalHandlers[key] = fn;
  config[key] = config[key] || {};
}
function parseMergedHandlers(mergedHandlers, mergedConfig) {
  const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers);
  const internalHandlers = {};
  registerGesture(actions, handlers, "onDrag", "drag", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onWheel", "wheel", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onScroll", "scroll", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onPinch", "pinch", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onMove", "move", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onHover", "hover", internalHandlers, mergedConfig);
  return {
    handlers: internalHandlers,
    config: mergedConfig,
    nativeHandlers
  };
}

// node_modules/@use-gesture/react/dist/use-gesture-react.esm.js
function useRecognizers(handlers, config = {}, gestureKey, nativeHandlers) {
  const ctrl = import_react.default.useMemo(() => new Controller(handlers), []);
  ctrl.applyHandlers(handlers, nativeHandlers);
  ctrl.applyConfig(config, gestureKey);
  import_react.default.useEffect(ctrl.effect.bind(ctrl));
  import_react.default.useEffect(() => {
    return ctrl.clean.bind(ctrl);
  }, []);
  if (config.target === void 0) {
    return ctrl.bind.bind(ctrl);
  }
  return void 0;
}
function createUseGesture(actions) {
  actions.forEach(registerAction);
  return function useGesture2(_handlers, _config) {
    const {
      handlers,
      nativeHandlers,
      config
    } = parseMergedHandlers(_handlers, _config || {});
    return useRecognizers(handlers, config, void 0, nativeHandlers);
  };
}
function useGesture(handlers, config) {
  const hook = createUseGesture([dragAction, pinchAction, scrollAction, wheelAction, moveAction, hoverAction]);
  return hook(handlers, config || {});
}

// node_modules/@tldraw/core/dist/index.mjs
var React22 = __toESM(require_react(), 1);
var import_react3 = __toESM(require_react(), 1);
var React3 = __toESM(require_react(), 1);
var React4 = __toESM(require_react(), 1);
var React5 = __toESM(require_react(), 1);
var React6 = __toESM(require_react(), 1);
var React7 = __toESM(require_react(), 1);
var React8 = __toESM(require_react(), 1);
var React9 = __toESM(require_react(), 1);
var React10 = __toESM(require_react(), 1);
var React11 = __toESM(require_react(), 1);
var React12 = __toESM(require_react(), 1);
var React13 = __toESM(require_react(), 1);
var React14 = __toESM(require_react(), 1);
var React15 = __toESM(require_react(), 1);
var React18 = __toESM(require_react(), 1);
var React19 = __toESM(require_react(), 1);
var React20 = __toESM(require_react(), 1);
var React21 = __toESM(require_react(), 1);
var React38 = __toESM(require_react(), 1);
var React30 = __toESM(require_react(), 1);
var React222 = __toESM(require_react(), 1);
var React23 = __toESM(require_react(), 1);
var React25 = __toESM(require_react(), 1);
var React24 = __toESM(require_react(), 1);
var React26 = __toESM(require_react(), 1);
var React27 = __toESM(require_react(), 1);
var React28 = __toESM(require_react(), 1);
var React29 = __toESM(require_react(), 1);
var React31 = __toESM(require_react(), 1);
var React33 = __toESM(require_react(), 1);
var React32 = __toESM(require_react(), 1);
var React36 = __toESM(require_react(), 1);
var React35 = __toESM(require_react(), 1);
var React34 = __toESM(require_react(), 1);
var React37 = __toESM(require_react(), 1);
var React39 = __toESM(require_react(), 1);
var React41 = __toESM(require_react(), 1);
var React40 = __toESM(require_react(), 1);
var React42 = __toESM(require_react(), 1);
var React43 = __toESM(require_react(), 1);
var React46 = __toESM(require_react(), 1);
var React47 = __toESM(require_react(), 1);
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var TLContext = React2.createContext({});
function useTLContext() {
  const context = React2.useContext(TLContext);
  return context;
}
var TLPerformanceMode = ((TLPerformanceMode2) => {
  TLPerformanceMode2["TransformSelected"] = "transform_selected";
  TLPerformanceMode2["TranslateSelected"] = "translate_selected";
  TLPerformanceMode2["TransformAll"] = "transform_all";
  TLPerformanceMode2["TranslateAll"] = "translate_all";
  return TLPerformanceMode2;
})(TLPerformanceMode || {});
var TLBoundsEdge = ((TLBoundsEdge2) => {
  TLBoundsEdge2["Top"] = "top_edge";
  TLBoundsEdge2["Right"] = "right_edge";
  TLBoundsEdge2["Bottom"] = "bottom_edge";
  TLBoundsEdge2["Left"] = "left_edge";
  return TLBoundsEdge2;
})(TLBoundsEdge || {});
var TLBoundsCorner = ((TLBoundsCorner2) => {
  TLBoundsCorner2["TopLeft"] = "top_left_corner";
  TLBoundsCorner2["TopRight"] = "top_right_corner";
  TLBoundsCorner2["BottomRight"] = "bottom_right_corner";
  TLBoundsCorner2["BottomLeft"] = "bottom_left_corner";
  return TLBoundsCorner2;
})(TLBoundsCorner || {});
var SnapPoints = ((SnapPoints2) => {
  SnapPoints2["minX"] = "minX";
  SnapPoints2["midX"] = "midX";
  SnapPoints2["maxX"] = "maxX";
  SnapPoints2["minY"] = "minY";
  SnapPoints2["midY"] = "midY";
  SnapPoints2["maxY"] = "maxY";
  return SnapPoints2;
})(SnapPoints || {});
if (!String.prototype.replaceAll) {
  String.prototype.replaceAll = function(str, newStr) {
    if (Object.prototype.toString.call(str).toLowerCase() === "[object regexp]") {
      return this.replace(str, newStr);
    }
    return this.replace(new RegExp(str, "g"), newStr);
  };
}
var TAU = Math.PI * 2;
var _Utils = class {
  static lerp(y1, y2, mu) {
    mu = _Utils.clamp(mu, 0, 1);
    return y1 * (1 - mu) + y2 * mu;
  }
  static lerpColor(color1, color2, factor = 0.5) {
    function h2r(hex) {
      const result2 = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return [parseInt(result2[1], 16), parseInt(result2[2], 16), parseInt(result2[3], 16)];
    }
    function r2h(rgb) {
      return "#" + ((1 << 24) + (rgb[0] << 16) + (rgb[1] << 8) + rgb[2]).toString(16).slice(1);
    }
    const c1 = h2r(color1) || [0, 0, 0];
    const c2 = h2r(color2) || [0, 0, 0];
    const result = c1.slice();
    for (let i = 0; i < 3; i++) {
      result[i] = Math.round(result[i] + factor * (c2[i] - c1[i]));
    }
    return r2h(result);
  }
  static modulate(value, rangeA, rangeB, clamp2 = false) {
    const [fromLow, fromHigh] = rangeA;
    const [v0, v1] = rangeB;
    const result = v0 + (value - fromLow) / (fromHigh - fromLow) * (v1 - v0);
    return clamp2 ? v0 < v1 ? Math.max(Math.min(result, v1), v0) : Math.max(Math.min(result, v0), v1) : result;
  }
  static clamp(n, min, max) {
    return Math.max(min, typeof max !== "undefined" ? Math.min(n, max) : n);
  }
  static deepClone(obj) {
    if (obj === null)
      return obj;
    if (Array.isArray(obj)) {
      return [...obj];
    }
    if (typeof obj === "object") {
      const clone = __spreadValues({}, obj);
      Object.keys(clone).forEach((key) => clone[key] = typeof obj[key] === "object" ? _Utils.deepClone(obj[key]) : obj[key]);
      return clone;
    }
    return obj;
  }
  static rng(seed = "") {
    let x = 0;
    let y = 0;
    let z = 0;
    let w = 0;
    function next() {
      const t = x ^ x << 11;
      x = y;
      y = z;
      z = w;
      w ^= (w >>> 19 ^ t ^ t >>> 8) >>> 0;
      return w / 4294967296;
    }
    for (let k = 0; k < seed.length + 64; k++) {
      x ^= seed.charCodeAt(k) | 0;
      next();
    }
    return next;
  }
  static pointsToLineSegments(points, closed = false) {
    const segments = [];
    for (let i = 1; i < points.length; i++)
      segments.push([points[i - 1], points[i]]);
    if (closed)
      segments.push([points[points.length - 1], points[0]]);
    return segments;
  }
  static getRectangleSides(point, size, rotation = 0) {
    const center = [point[0] + size[0] / 2, point[1] + size[1] / 2];
    const tl = e.rotWith(point, center, rotation);
    const tr = e.rotWith(e.add(point, [size[0], 0]), center, rotation);
    const br = e.rotWith(e.add(point, size), center, rotation);
    const bl = e.rotWith(e.add(point, [0, size[1]]), center, rotation);
    return [
      ["top", [tl, tr]],
      ["right", [tr, br]],
      ["bottom", [br, bl]],
      ["left", [bl, tl]]
    ];
  }
  static circleFromThreePoints(A, B, C) {
    const [x1, y1] = A;
    const [x2, y2] = B;
    const [x3, y3] = C;
    const a = x1 * (y2 - y3) - y1 * (x2 - x3) + x2 * y3 - x3 * y2;
    const b = (x1 * x1 + y1 * y1) * (y3 - y2) + (x2 * x2 + y2 * y2) * (y1 - y3) + (x3 * x3 + y3 * y3) * (y2 - y1);
    const c = (x1 * x1 + y1 * y1) * (x2 - x3) + (x2 * x2 + y2 * y2) * (x3 - x1) + (x3 * x3 + y3 * y3) * (x1 - x2);
    const x = -b / (2 * a);
    const y = -c / (2 * a);
    return [x, y, Math.hypot(x - x1, y - y1)];
  }
  static perimeterOfEllipse(rx, ry) {
    const h = Math.pow(rx - ry, 2) / Math.pow(rx + ry, 2);
    const p = Math.PI * (rx + ry) * (1 + 3 * h / (10 + Math.sqrt(4 - 3 * h)));
    return p;
  }
  static shortAngleDist(a0, a1) {
    const max = Math.PI * 2;
    const da = (a1 - a0) % max;
    return 2 * da % max - da;
  }
  static longAngleDist(a0, a1) {
    return Math.PI * 2 - _Utils.shortAngleDist(a0, a1);
  }
  static lerpAngles(a0, a1, t) {
    return a0 + _Utils.shortAngleDist(a0, a1) * t;
  }
  static angleDelta(a0, a1) {
    return _Utils.shortAngleDist(a0, a1);
  }
  static getSweep(C, A, B) {
    return _Utils.angleDelta(e.angle(C, A), e.angle(C, B));
  }
  static clampRadians(r) {
    return (Math.PI * 2 + r) % (Math.PI * 2);
  }
  static snapAngleToSegments(r, segments) {
    const seg = Math.PI * 2 / segments;
    return Math.floor((_Utils.clampRadians(r) + seg / 2) / seg) * seg;
  }
  static isAngleBetween(a, b, c) {
    if (c === a || c === b)
      return true;
    const AB = (b - a + TAU) % TAU;
    const AC = (c - a + TAU) % TAU;
    return AB <= Math.PI !== AC > AB;
  }
  static degreesToRadians(d) {
    return d * Math.PI / 180;
  }
  static radiansToDegrees(r) {
    return r * 180 / Math.PI;
  }
  static getArcLength(C, r, A, B) {
    const sweep = _Utils.getSweep(C, A, B);
    return r * (2 * Math.PI) * (sweep / (2 * Math.PI));
  }
  static getSweepFlag(A, B, C) {
    const angleAC = e.angle(A, C);
    const angleAB = e.angle(A, B);
    const angleCAB = (angleAB - angleAC + 3 * Math.PI) % (2 * Math.PI) - Math.PI;
    return angleCAB > 0 ? 0 : 1;
  }
  static getLargeArcFlag(A, C, P) {
    const anglePA = e.angle(P, A);
    const anglePC = e.angle(P, C);
    const angleAPC = (anglePC - anglePA + 3 * Math.PI) % (2 * Math.PI) - Math.PI;
    return Math.abs(angleAPC) > Math.PI / 2 ? 0 : 1;
  }
  static getArcDashOffset(C, r, A, B, step) {
    const del0 = _Utils.getSweepFlag(C, A, B);
    const len0 = _Utils.getArcLength(C, r, A, B);
    const off0 = del0 < 0 ? len0 : 2 * Math.PI * C[2] - len0;
    return -off0 / 2 + step;
  }
  static getEllipseDashOffset(A, step) {
    const c = 2 * Math.PI * A[2];
    return -c / 2 + -step;
  }
  static pointInCircle(A, C, r) {
    return e.dist(A, C) <= r;
  }
  static pointInEllipse(A, C, rx, ry, rotation = 0) {
    rotation = rotation || 0;
    const cos = Math.cos(rotation);
    const sin = Math.sin(rotation);
    const delta = e.sub(A, C);
    const tdx = cos * delta[0] + sin * delta[1];
    const tdy = sin * delta[0] - cos * delta[1];
    return tdx * tdx / (rx * rx) + tdy * tdy / (ry * ry) <= 1;
  }
  static pointInRect(point, size) {
    return !(point[0] < size[0] || point[0] > point[0] + size[0] || point[1] < size[1] || point[1] > point[1] + size[1]);
  }
  static pointInPolygon(p, points) {
    let wn = 0;
    points.forEach((a, i) => {
      const b = points[(i + 1) % points.length];
      if (a[1] <= p[1]) {
        if (b[1] > p[1] && e.cross(a, b, p) > 0) {
          wn += 1;
        }
      } else if (b[1] <= p[1] && e.cross(a, b, p) < 0) {
        wn -= 1;
      }
    });
    return wn !== 0;
  }
  static pointInBounds(A, b) {
    return !(A[0] < b.minX || A[0] > b.maxX || A[1] < b.minY || A[1] > b.maxY);
  }
  static pointInPolyline(A, points, distance = 3) {
    for (let i = 1; i < points.length; i++) {
      if (e.distanceToLineSegment(points[i - 1], points[i], A) < distance) {
        return true;
      }
    }
    return false;
  }
  static getBoundsSides(bounds) {
    return this.getRectangleSides([bounds.minX, bounds.minY], [bounds.width, bounds.height]);
  }
  static expandBounds(bounds, delta) {
    return {
      minX: bounds.minX - delta,
      minY: bounds.minY - delta,
      maxX: bounds.maxX + delta,
      maxY: bounds.maxY + delta,
      width: bounds.width + delta * 2,
      height: bounds.height + delta * 2
    };
  }
  static boundsCollide(a, b) {
    return !(a.maxX < b.minX || a.minX > b.maxX || a.maxY < b.minY || a.minY > b.maxY);
  }
  static boundsContain(a, b) {
    return a.minX < b.minX && a.minY < b.minY && a.maxY > b.maxY && a.maxX > b.maxX;
  }
  static boundsContained(a, b) {
    return _Utils.boundsContain(b, a);
  }
  static boundsAreEqual(a, b) {
    return !(b.maxX !== a.maxX || b.minX !== a.minX || b.maxY !== a.maxY || b.minY !== a.minY);
  }
  static getBoundsFromPoints(points, rotation = 0) {
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    if (points.length < 2) {
      minX = 0;
      minY = 0;
      maxX = 1;
      maxY = 1;
    } else {
      for (const [x, y] of points) {
        minX = Math.min(x, minX);
        minY = Math.min(y, minY);
        maxX = Math.max(x, maxX);
        maxY = Math.max(y, maxY);
      }
    }
    if (rotation !== 0) {
      return _Utils.getBoundsFromPoints(points.map((pt) => e.rotWith(pt, [(minX + maxX) / 2, (minY + maxY) / 2], rotation)));
    }
    return {
      minX,
      minY,
      maxX,
      maxY,
      width: Math.max(1, maxX - minX),
      height: Math.max(1, maxY - minY)
    };
  }
  static centerBounds(bounds, point) {
    const boundsCenter = this.getBoundsCenter(bounds);
    const dx = point[0] - boundsCenter[0];
    const dy = point[1] - boundsCenter[1];
    return this.translateBounds(bounds, [dx, dy]);
  }
  static snapBoundsToGrid(bounds, gridSize) {
    const minX = Math.round(bounds.minX / gridSize) * gridSize;
    const minY = Math.round(bounds.minY / gridSize) * gridSize;
    const maxX = Math.round(bounds.maxX / gridSize) * gridSize;
    const maxY = Math.round(bounds.maxY / gridSize) * gridSize;
    return {
      minX,
      minY,
      maxX,
      maxY,
      width: Math.max(1, maxX - minX),
      height: Math.max(1, maxY - minY)
    };
  }
  static translateBounds(bounds, delta) {
    return {
      minX: bounds.minX + delta[0],
      minY: bounds.minY + delta[1],
      maxX: bounds.maxX + delta[0],
      maxY: bounds.maxY + delta[1],
      width: bounds.width,
      height: bounds.height
    };
  }
  static rotateBounds(bounds, center, rotation) {
    const [minX, minY] = e.rotWith([bounds.minX, bounds.minY], center, rotation);
    const [maxX, maxY] = e.rotWith([bounds.maxX, bounds.maxY], center, rotation);
    return {
      minX,
      minY,
      maxX,
      maxY,
      width: bounds.width,
      height: bounds.height
    };
  }
  static getRotatedEllipseBounds(x, y, rx, ry, rotation = 0) {
    const c = Math.cos(rotation);
    const s = Math.sin(rotation);
    const w = Math.hypot(rx * c, ry * s);
    const h = Math.hypot(rx * s, ry * c);
    return {
      minX: x + rx - w,
      minY: y + ry - h,
      maxX: x + rx + w,
      maxY: y + ry + h,
      width: w * 2,
      height: h * 2
    };
  }
  static getExpandedBounds(a, b) {
    const minX = Math.min(a.minX, b.minX);
    const minY = Math.min(a.minY, b.minY);
    const maxX = Math.max(a.maxX, b.maxX);
    const maxY = Math.max(a.maxY, b.maxY);
    const width = Math.abs(maxX - minX);
    const height = Math.abs(maxY - minY);
    return { minX, minY, maxX, maxY, width, height };
  }
  static getCommonBounds(bounds) {
    if (bounds.length < 2)
      return bounds[0];
    let result = bounds[0];
    for (let i = 1; i < bounds.length; i++) {
      result = _Utils.getExpandedBounds(result, bounds[i]);
    }
    return result;
  }
  static getRotatedCorners(b, rotation = 0) {
    const center = [b.minX + b.width / 2, b.minY + b.height / 2];
    return [
      [b.minX, b.minY],
      [b.maxX, b.minY],
      [b.maxX, b.maxY],
      [b.minX, b.maxY]
    ].map((point) => e.rotWith(point, center, rotation));
  }
  static getTransformedBoundingBox(bounds, handle, delta, rotation = 0, isAspectRatioLocked = false) {
    const [ax0, ay0] = [bounds.minX, bounds.minY];
    const [ax1, ay1] = [bounds.maxX, bounds.maxY];
    let [bx0, by0] = [bounds.minX, bounds.minY];
    let [bx1, by1] = [bounds.maxX, bounds.maxY];
    if (handle === "center") {
      return {
        minX: bx0 + delta[0],
        minY: by0 + delta[1],
        maxX: bx1 + delta[0],
        maxY: by1 + delta[1],
        width: bx1 - bx0,
        height: by1 - by0,
        scaleX: 1,
        scaleY: 1
      };
    }
    const [dx, dy] = e.rot(delta, -rotation);
    switch (handle) {
      case "top_edge":
      case "top_left_corner":
      case "top_right_corner": {
        by0 += dy;
        break;
      }
      case "bottom_edge":
      case "bottom_left_corner":
      case "bottom_right_corner": {
        by1 += dy;
        break;
      }
    }
    switch (handle) {
      case "left_edge":
      case "top_left_corner":
      case "bottom_left_corner": {
        bx0 += dx;
        break;
      }
      case "right_edge":
      case "top_right_corner":
      case "bottom_right_corner": {
        bx1 += dx;
        break;
      }
    }
    const aw = ax1 - ax0;
    const ah = ay1 - ay0;
    const scaleX = (bx1 - bx0) / aw;
    const scaleY = (by1 - by0) / ah;
    const flipX = scaleX < 0;
    const flipY = scaleY < 0;
    const bw = Math.abs(bx1 - bx0);
    const bh = Math.abs(by1 - by0);
    if (isAspectRatioLocked) {
      const ar = aw / ah;
      const isTall = ar < bw / bh;
      const tw = bw * (scaleY < 0 ? 1 : -1) * (1 / ar);
      const th = bh * (scaleX < 0 ? 1 : -1) * ar;
      switch (handle) {
        case "top_left_corner": {
          if (isTall)
            by0 = by1 + tw;
          else
            bx0 = bx1 + th;
          break;
        }
        case "top_right_corner": {
          if (isTall)
            by0 = by1 + tw;
          else
            bx1 = bx0 - th;
          break;
        }
        case "bottom_right_corner": {
          if (isTall)
            by1 = by0 - tw;
          else
            bx1 = bx0 - th;
          break;
        }
        case "bottom_left_corner": {
          if (isTall)
            by1 = by0 - tw;
          else
            bx0 = bx1 + th;
          break;
        }
        case "bottom_edge":
        case "top_edge": {
          const m = (bx0 + bx1) / 2;
          const w = bh * ar;
          bx0 = m - w / 2;
          bx1 = m + w / 2;
          break;
        }
        case "left_edge":
        case "right_edge": {
          const m = (by0 + by1) / 2;
          const h = bw / ar;
          by0 = m - h / 2;
          by1 = m + h / 2;
          break;
        }
      }
    }
    if (rotation % (Math.PI * 2) !== 0) {
      let cv = [0, 0];
      const c0 = e.med([ax0, ay0], [ax1, ay1]);
      const c1 = e.med([bx0, by0], [bx1, by1]);
      switch (handle) {
        case "top_left_corner": {
          cv = e.sub(e.rotWith([bx1, by1], c1, rotation), e.rotWith([ax1, ay1], c0, rotation));
          break;
        }
        case "top_right_corner": {
          cv = e.sub(e.rotWith([bx0, by1], c1, rotation), e.rotWith([ax0, ay1], c0, rotation));
          break;
        }
        case "bottom_right_corner": {
          cv = e.sub(e.rotWith([bx0, by0], c1, rotation), e.rotWith([ax0, ay0], c0, rotation));
          break;
        }
        case "bottom_left_corner": {
          cv = e.sub(e.rotWith([bx1, by0], c1, rotation), e.rotWith([ax1, ay0], c0, rotation));
          break;
        }
        case "top_edge": {
          cv = e.sub(e.rotWith(e.med([bx0, by1], [bx1, by1]), c1, rotation), e.rotWith(e.med([ax0, ay1], [ax1, ay1]), c0, rotation));
          break;
        }
        case "left_edge": {
          cv = e.sub(e.rotWith(e.med([bx1, by0], [bx1, by1]), c1, rotation), e.rotWith(e.med([ax1, ay0], [ax1, ay1]), c0, rotation));
          break;
        }
        case "bottom_edge": {
          cv = e.sub(e.rotWith(e.med([bx0, by0], [bx1, by0]), c1, rotation), e.rotWith(e.med([ax0, ay0], [ax1, ay0]), c0, rotation));
          break;
        }
        case "right_edge": {
          cv = e.sub(e.rotWith(e.med([bx0, by0], [bx0, by1]), c1, rotation), e.rotWith(e.med([ax0, ay0], [ax0, ay1]), c0, rotation));
          break;
        }
      }
      ;
      [bx0, by0] = e.sub([bx0, by0], cv);
      [bx1, by1] = e.sub([bx1, by1], cv);
    }
    if (bx1 < bx0) {
      ;
      [bx1, bx0] = [bx0, bx1];
    }
    if (by1 < by0) {
      ;
      [by1, by0] = [by0, by1];
    }
    return {
      minX: bx0,
      minY: by0,
      maxX: bx1,
      maxY: by1,
      width: bx1 - bx0,
      height: by1 - by0,
      scaleX: (bx1 - bx0) / (ax1 - ax0 || 1) * (flipX ? -1 : 1),
      scaleY: (by1 - by0) / (ay1 - ay0 || 1) * (flipY ? -1 : 1)
    };
  }
  static getTransformAnchor(type, isFlippedX, isFlippedY) {
    let anchor = type;
    switch (type) {
      case "top_left_corner": {
        if (isFlippedX && isFlippedY) {
          anchor = "bottom_right_corner";
        } else if (isFlippedX) {
          anchor = "top_right_corner";
        } else if (isFlippedY) {
          anchor = "bottom_left_corner";
        } else {
          anchor = "bottom_right_corner";
        }
        break;
      }
      case "top_right_corner": {
        if (isFlippedX && isFlippedY) {
          anchor = "bottom_left_corner";
        } else if (isFlippedX) {
          anchor = "top_left_corner";
        } else if (isFlippedY) {
          anchor = "bottom_right_corner";
        } else {
          anchor = "bottom_left_corner";
        }
        break;
      }
      case "bottom_right_corner": {
        if (isFlippedX && isFlippedY) {
          anchor = "top_left_corner";
        } else if (isFlippedX) {
          anchor = "bottom_left_corner";
        } else if (isFlippedY) {
          anchor = "top_right_corner";
        } else {
          anchor = "top_left_corner";
        }
        break;
      }
      case "bottom_left_corner": {
        if (isFlippedX && isFlippedY) {
          anchor = "top_right_corner";
        } else if (isFlippedX) {
          anchor = "bottom_right_corner";
        } else if (isFlippedY) {
          anchor = "top_left_corner";
        } else {
          anchor = "top_right_corner";
        }
        break;
      }
    }
    return anchor;
  }
  static getRelativeTransformedBoundingBox(bounds, initialBounds, initialShapeBounds, isFlippedX, isFlippedY) {
    const nx = (isFlippedX ? initialBounds.maxX - initialShapeBounds.maxX : initialShapeBounds.minX - initialBounds.minX) / initialBounds.width;
    const ny = (isFlippedY ? initialBounds.maxY - initialShapeBounds.maxY : initialShapeBounds.minY - initialBounds.minY) / initialBounds.height;
    const nw = initialShapeBounds.width / initialBounds.width;
    const nh = initialShapeBounds.height / initialBounds.height;
    const minX = bounds.minX + bounds.width * nx;
    const minY = bounds.minY + bounds.height * ny;
    const width = bounds.width * nw;
    const height = bounds.height * nh;
    return {
      minX,
      minY,
      maxX: minX + width,
      maxY: minY + height,
      width,
      height
    };
  }
  static getRotatedSize(size, rotation) {
    const center = e.div(size, 2);
    const points = [[0, 0], [size[0], 0], size, [0, size[1]]].map((point) => e.rotWith(point, center, rotation));
    const bounds = _Utils.getBoundsFromPoints(points);
    return [bounds.width, bounds.height];
  }
  static getBoundsCenter(bounds) {
    return [bounds.minX + bounds.width / 2, bounds.minY + bounds.height / 2];
  }
  static getBoundsWithCenter(bounds) {
    const center = _Utils.getBoundsCenter(bounds);
    return __spreadProps(__spreadValues({}, bounds), {
      midX: center[0],
      midY: center[1]
    });
  }
  static getCommonTopLeft(points) {
    const min = [Infinity, Infinity];
    points.forEach((point) => {
      min[0] = Math.min(min[0], point[0]);
      min[1] = Math.min(min[1], point[1]);
    });
    return min;
  }
  static getFromCache(cache, item, getNext) {
    let value = cache.get(item);
    if (value === void 0) {
      cache.set(item, getNext());
      value = cache.get(item);
      if (value === void 0) {
        throw Error("Cache did not include item!");
      }
    }
    return value;
  }
  static uniqueId(a = "") {
    return a ? ((Number(a) ^ Math.random() * 16) >> Number(a) / 4).toString(16) : `${1e7}-${1e3}-${4e3}-${8e3}-${1e11}`.replace(/[018]/g, _Utils.uniqueId);
  }
  static rotateArray(arr, offset) {
    return arr.map((_, i) => arr[(i + offset) % arr.length]);
  }
  static debounce(fn, ms = 0) {
    let timeoutId;
    return function(...args) {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => fn.apply(args), ms);
    };
  }
  static getSvgPathFromStroke(points, closed = true) {
    const len = points.length;
    if (len < 4) {
      return ``;
    }
    let a = points[0];
    let b = points[1];
    const c = points[2];
    let result = `M${a[0].toFixed(2)},${a[1].toFixed(2)} Q${b[0].toFixed(2)},${b[1].toFixed(2)} ${average(b[0], c[0]).toFixed(2)},${average(b[1], c[1]).toFixed(2)} T`;
    for (let i = 2, max = len - 1; i < max; i++) {
      a = points[i];
      b = points[i + 1];
      result += `${average(a[0], b[0]).toFixed(2)},${average(a[1], b[1]).toFixed(2)} `;
    }
    if (closed) {
      result += "Z";
    }
    return result;
  }
  static getSvgPathFromStrokePoints(points, closed = false) {
    const len = points.length;
    if (len < 4) {
      return ``;
    }
    let a = points[0].point;
    let b = points[1].point;
    const c = points[2].point;
    let result = `M${a[0].toFixed(2)},${a[1].toFixed(2)} Q${b[0].toFixed(2)},${b[1].toFixed(2)} ${average(b[0], c[0]).toFixed(2)},${average(b[1], c[1]).toFixed(2)} T`;
    for (let i = 2, max = len - 1; i < max; i++) {
      a = points[i].point;
      b = points[i + 1].point;
      result += `${average(a[0], b[0]).toFixed(2)},${average(a[1], b[1]).toFixed(2)} `;
    }
    if (closed) {
      result += "Z";
    }
    return result;
  }
  static getPerfectDashProps(length, strokeWidth, style, snap = 1, outset = true, lengthRatio = 2) {
    let dashLength;
    let strokeDashoffset;
    let ratio;
    if (style.toLowerCase() === "dashed") {
      dashLength = strokeWidth * lengthRatio;
      ratio = 1;
      strokeDashoffset = outset ? (dashLength / 2).toString() : "0";
    } else if (style.toLowerCase() === "dotted") {
      dashLength = strokeWidth / 100;
      ratio = 100;
      strokeDashoffset = "0";
    } else {
      return {
        strokeDasharray: "none",
        strokeDashoffset: "none"
      };
    }
    let dashes = Math.floor(length / dashLength / (2 * ratio));
    dashes -= dashes % snap;
    dashes = Math.max(dashes, 4);
    const gapLength = Math.max(dashLength, (length - dashes * dashLength) / (outset ? dashes : dashes - 1));
    return {
      strokeDasharray: [dashLength, gapLength].join(" "),
      strokeDashoffset
    };
  }
  static isMobileSafari() {
    if (typeof window === "undefined")
      return false;
    const ua = window.navigator.userAgent;
    const iOS = !!ua.match(/iPad/i) || !!ua.match(/iPhone/i);
    const webkit = !!ua.match(/WebKit/i);
    return iOS && webkit && !ua.match(/CriOS/i);
  }
  static throttle(func, limit) {
    let inThrottle;
    let lastResult;
    return function(...args) {
      if (!inThrottle) {
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
        lastResult = func(...args);
      }
      return lastResult;
    };
  }
  static isDarwin() {
    return /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
  }
  static metaKey(e2) {
    return _Utils.isDarwin() ? e2.metaKey : e2.ctrlKey;
  }
  static lns(str) {
    const result = str.split("");
    result.push(...result.splice(0, Math.round(result.length / 5)));
    result.push(...result.splice(0, Math.round(result.length / 4)));
    result.push(...result.splice(0, Math.round(result.length / 3)));
    result.push(...result.splice(0, Math.round(result.length / 2)));
    return result.reverse().map((n) => +n ? +n < 5 ? 5 + +n : +n > 5 ? +n - 5 : n : n).join("");
  }
};
var Utils = _Utils;
__publicField(Utils, "getSnapPoints", (bounds, others, snapDistance) => {
  const A = __spreadValues({}, bounds);
  const offset = [0, 0];
  const snapLines = [];
  const snaps = {
    ["minX"]: { id: "minX", isSnapped: false },
    ["midX"]: { id: "midX", isSnapped: false },
    ["maxX"]: { id: "maxX", isSnapped: false },
    ["minY"]: { id: "minY", isSnapped: false },
    ["midY"]: { id: "midY", isSnapped: false },
    ["maxY"]: { id: "maxY", isSnapped: false }
  };
  const xs = ["midX", "minX", "maxX"];
  const ys = ["midY", "minY", "maxY"];
  const snapResults = others.map((B) => {
    const rx = xs.flatMap((f, i) => xs.map((t, k) => {
      const gap = A[f] - B[t];
      const distance = Math.abs(gap);
      return {
        f,
        t,
        gap,
        distance,
        isCareful: i === 0 || i + k === 3
      };
    }));
    const ry = ys.flatMap((f, i) => ys.map((t, k) => {
      const gap = A[f] - B[t];
      const distance = Math.abs(gap);
      return {
        f,
        t,
        gap,
        distance,
        isCareful: i === 0 || i + k === 3
      };
    }));
    return [B, rx, ry];
  });
  let gapX = Infinity;
  let gapY = Infinity;
  let minX = Infinity;
  let minY = Infinity;
  snapResults.forEach(([_, rx, ry]) => {
    rx.forEach((r) => {
      if (r.distance < snapDistance && r.distance < minX) {
        minX = r.distance;
        gapX = r.gap;
      }
    });
    ry.forEach((r) => {
      if (r.distance < snapDistance && r.distance < minY) {
        minY = r.distance;
        gapY = r.gap;
      }
    });
  });
  snapResults.forEach(([B, rx, ry]) => {
    if (gapX !== Infinity) {
      rx.forEach((r) => {
        if (Math.abs(r.gap - gapX) < 2) {
          snaps[r.f] = __spreadProps(__spreadValues({}, snaps[r.f]), {
            isSnapped: true,
            to: B[r.t],
            B,
            distance: r.distance
          });
        }
      });
    }
    if (gapY !== Infinity) {
      ry.forEach((r) => {
        if (Math.abs(r.gap - gapY) < 2) {
          snaps[r.f] = __spreadProps(__spreadValues({}, snaps[r.f]), {
            isSnapped: true,
            to: B[r.t],
            B,
            distance: r.distance
          });
        }
      });
    }
  });
  offset[0] = gapX === Infinity ? 0 : gapX;
  offset[1] = gapY === Infinity ? 0 : gapY;
  A.minX -= offset[0];
  A.midX -= offset[0];
  A.maxX -= offset[0];
  A.minY -= offset[1];
  A.midY -= offset[1];
  A.maxY -= offset[1];
  xs.forEach((from) => {
    const snap = snaps[from];
    if (!snap.isSnapped)
      return;
    const { id, B } = snap;
    const x = A[id];
    snapLines.push(id === "minX" ? [
      [x, A.midY],
      [x, B.minY],
      [x, B.maxY]
    ] : [
      [x, A.minY],
      [x, A.maxY],
      [x, B.minY],
      [x, B.maxY]
    ]);
  });
  ys.forEach((from) => {
    const snap = snaps[from];
    if (!snap.isSnapped)
      return;
    const { id, B } = snap;
    const y = A[id];
    snapLines.push(id === "midY" ? [
      [A.midX, y],
      [B.minX, y],
      [B.maxX, y]
    ] : [
      [A.minX, y],
      [A.maxX, y],
      [B.minX, y],
      [B.maxX, y]
    ]);
  });
  return { offset, snapLines };
});
__publicField(Utils, "deepMerge", (target, patch) => {
  const result = __spreadValues({}, target);
  const entries = Object.entries(patch);
  for (const [key, value] of entries)
    result[key] = value === Object(value) && !Array.isArray(value) ? _Utils.deepMerge(result[key], value) : value;
  return result;
});
function average(a, b) {
  return (a + b) / 2;
}
var utils_default = Utils;
function useZoomEvents(zoomRef, ref) {
  const rOriginPoint = React22.useRef(void 0);
  const rPinchPoint = React22.useRef(void 0);
  const rDelta = React22.useRef([0, 0]);
  const { inputs: inputs2, bounds, callbacks } = useTLContext();
  React22.useEffect(() => {
    const preventGesture = (event) => event.preventDefault();
    document.addEventListener("gesturestart", preventGesture);
    document.addEventListener("gesturechange", preventGesture);
    return () => {
      document.removeEventListener("gesturestart", preventGesture);
      document.removeEventListener("gesturechange", preventGesture);
    };
  }, []);
  const handleWheel = React22.useCallback(({ event: e2 }) => {
    var _a, _b, _c, _d;
    e2.preventDefault();
    if (inputs2.isPinching)
      return;
    const [x, y, z] = normalizeWheel(e2);
    if ((e2.altKey || e2.ctrlKey || e2.metaKey) && e2.buttons === 0) {
      const point = (_b = (_a = inputs2.pointer) == null ? void 0 : _a.point) != null ? _b : [bounds.width / 2, bounds.height / 2];
      const delta2 = [...point, z * 0.618];
      const info2 = inputs2.pan(delta2, e2);
      (_c = callbacks.onZoom) == null ? void 0 : _c.call(callbacks, __spreadProps(__spreadValues({}, info2), { delta: delta2 }), e2);
      return;
    }
    const delta = e.mul(e2.shiftKey && !utils_default.isDarwin ? [y, 0] : [x, y], 0.5);
    if (e.isEqual(delta, [0, 0]))
      return;
    const info = inputs2.pan(delta, e2);
    (_d = callbacks.onPan) == null ? void 0 : _d.call(callbacks, info, e2);
  }, [callbacks, inputs2, bounds]);
  const handlePinchStart = React22.useCallback(({ origin, event }) => {
    var _a;
    if (event instanceof WheelEvent)
      return;
    const elm = ref.current;
    if (!elm || !(event.target === elm || elm.contains(event.target)))
      return;
    const info = inputs2.pinch(origin, origin);
    inputs2.isPinching = true;
    (_a = callbacks.onPinchStart) == null ? void 0 : _a.call(callbacks, info, event);
    rPinchPoint.current = info.point;
    rOriginPoint.current = info.origin;
    rDelta.current = [0, 0];
  }, [callbacks, inputs2, bounds]);
  const handlePinch = React22.useCallback(({ origin, offset, event }) => {
    var _a;
    if (event instanceof WheelEvent)
      return;
    const elm = ref.current;
    if (!(event.target === elm || (elm == null ? void 0 : elm.contains(event.target))))
      return;
    if (!rOriginPoint.current)
      return;
    const info = inputs2.pinch(origin, rOriginPoint.current);
    const trueDelta = e.sub(info.delta, rDelta.current);
    rDelta.current = info.delta;
    (_a = callbacks.onPinch) == null ? void 0 : _a.call(callbacks, __spreadProps(__spreadValues({}, info), {
      point: info.point,
      origin: rOriginPoint.current,
      delta: [...trueDelta, offset[0]]
    }), event);
    rPinchPoint.current = origin;
  }, [callbacks, inputs2, bounds]);
  const handlePinchEnd = React22.useCallback(({ origin, event }) => {
    var _a;
    const elm = ref.current;
    if (!(event.target === elm || (elm == null ? void 0 : elm.contains(event.target))))
      return;
    const info = inputs2.pinch(origin, origin);
    inputs2.isPinching = false;
    (_a = callbacks.onPinchEnd) == null ? void 0 : _a.call(callbacks, info, event);
    rPinchPoint.current = void 0;
    rOriginPoint.current = void 0;
    rDelta.current = [0, 0];
  }, []);
  useGesture({
    onWheel: handleWheel,
    onPinchStart: handlePinchStart,
    onPinch: handlePinch,
    onPinchEnd: handlePinchEnd
  }, {
    target: ref,
    eventOptions: { passive: false },
    pinch: {
      from: [zoomRef.current, 0],
      scaleBounds: () => {
        return { from: zoomRef.current, max: 5, min: 0.1 };
      }
    }
  });
}
var MAX_ZOOM_STEP = 10;
function normalizeWheel(event) {
  const { deltaY, deltaX } = event;
  let deltaZ = 0;
  if (event.ctrlKey || event.metaKey) {
    const signY = Math.sign(event.deltaY);
    const absDeltaY = Math.abs(event.deltaY);
    let dy = deltaY;
    if (absDeltaY > MAX_ZOOM_STEP) {
      dy = MAX_ZOOM_STEP * signY;
    }
    deltaZ = dy;
  }
  return [deltaX, deltaY, deltaZ];
}
function useSafariFocusOutFix() {
  const { callbacks } = useTLContext();
  (0, import_react3.useEffect)(() => {
    function handleFocusOut() {
      var _a;
      (_a = callbacks.onShapeBlur) == null ? void 0 : _a.call(callbacks);
    }
    if (utils_default.isMobileSafari()) {
      document.addEventListener("focusout", handleFocusOut);
      return () => document.removeEventListener("focusout", handleFocusOut);
    }
    return () => null;
  }, [callbacks]);
}
function useCanvasEvents() {
  const { callbacks, inputs: inputs2 } = useTLContext();
  return React3.useMemo(() => {
    return {
      onPointerDown: (e2) => {
        var _a, _b, _c;
        if (e2.dead)
          return;
        else
          e2.dead = true;
        if (!inputs2.pointerIsValid(e2))
          return;
        e2.currentTarget.setPointerCapture(e2.pointerId);
        if (e2.button === 2) {
          (_a = callbacks.onRightPointCanvas) == null ? void 0 : _a.call(callbacks, inputs2.pointerDown(e2, "canvas"), e2);
          return;
        }
        const info = inputs2.pointerDown(e2, "canvas");
        if (e2.button === 0) {
          (_b = callbacks.onPointCanvas) == null ? void 0 : _b.call(callbacks, info, e2);
        }
        (_c = callbacks.onPointerDown) == null ? void 0 : _c.call(callbacks, info, e2);
      },
      onPointerMove: (e2) => {
        var _a, _b;
        if (e2.dead)
          return;
        else
          e2.dead = true;
        if (!inputs2.pointerIsValid(e2))
          return;
        const info = inputs2.pointerMove(e2, "canvas");
        if (e2.buttons === 1) {
          if (e2.currentTarget.hasPointerCapture(e2.pointerId)) {
            (_a = callbacks.onDragCanvas) == null ? void 0 : _a.call(callbacks, info, e2);
          }
        }
        (_b = callbacks.onPointerMove) == null ? void 0 : _b.call(callbacks, info, e2);
      },
      onPointerUp: (e2) => {
        var _a, _b, _c, _d, _e2;
        if (e2.dead)
          return;
        else
          e2.dead = true;
        inputs2.activePointer = void 0;
        if (!inputs2.pointerIsValid(e2))
          return;
        const info = inputs2.pointerUp(e2, "canvas");
        if (e2.button === 2) {
          (_a = callbacks.onPointerUp) == null ? void 0 : _a.call(callbacks, info, e2);
          return;
        }
        const isDoubleClick = inputs2.isDoubleClick();
        if (e2.currentTarget.hasPointerCapture(e2.pointerId)) {
          (_b = e2.currentTarget) == null ? void 0 : _b.releasePointerCapture(e2.pointerId);
        }
        if (e2.button === 0) {
          if (isDoubleClick && !(info.altKey || info.metaKey)) {
            (_c = callbacks.onDoubleClickCanvas) == null ? void 0 : _c.call(callbacks, info, e2);
          }
          (_d = callbacks.onReleaseCanvas) == null ? void 0 : _d.call(callbacks, info, e2);
        }
        (_e2 = callbacks.onPointerUp) == null ? void 0 : _e2.call(callbacks, info, e2);
      },
      onDrop: callbacks.onDrop,
      onDragOver: callbacks.onDragOver
    };
  }, [callbacks, inputs2]);
}
function useShapeEvents(id) {
  const { rPageState, rSelectionBounds, callbacks, inputs: inputs2 } = React4.useContext(TLContext);
  return React4.useMemo(() => ({
    onPointerDown: (e2) => {
      var _a, _b, _c, _d, _e2, _f, _g;
      if (e2.dead)
        return;
      else
        e2.dead = true;
      if (!inputs2.pointerIsValid(e2))
        return;
      if (e2.button === 2) {
        (_a = callbacks.onRightPointShape) == null ? void 0 : _a.call(callbacks, inputs2.pointerDown(e2, id), e2);
        return;
      }
      const info = inputs2.pointerDown(e2, id);
      (_b = e2.currentTarget) == null ? void 0 : _b.setPointerCapture(e2.pointerId);
      if (rSelectionBounds.current && Utils.pointInBounds(info.point, rSelectionBounds.current) && !rPageState.current.selectedIds.includes(id)) {
        if (e2.button === 0) {
          (_c = callbacks.onPointBounds) == null ? void 0 : _c.call(callbacks, inputs2.pointerDown(e2, "bounds"), e2);
          (_d = callbacks.onPointShape) == null ? void 0 : _d.call(callbacks, info, e2);
        }
        (_e2 = callbacks.onPointerDown) == null ? void 0 : _e2.call(callbacks, info, e2);
        return;
      }
      if (e2.button === 0) {
        (_f = callbacks.onPointShape) == null ? void 0 : _f.call(callbacks, info, e2);
      }
      (_g = callbacks.onPointerDown) == null ? void 0 : _g.call(callbacks, info, e2);
    },
    onPointerUp: (e2) => {
      var _a, _b, _c, _d;
      if (e2.dead)
        return;
      else
        e2.dead = true;
      if (!inputs2.pointerIsValid(e2))
        return;
      if (e2.button === 2) {
        return;
      }
      inputs2.activePointer = void 0;
      const isDoubleClick = inputs2.isDoubleClick();
      const info = inputs2.pointerUp(e2, id);
      if (e2.pointerId && e2.currentTarget.hasPointerCapture(e2.pointerId)) {
        (_a = e2.currentTarget) == null ? void 0 : _a.releasePointerCapture(e2.pointerId);
      }
      if (e2.button === 0) {
        if (isDoubleClick && !(info.altKey || info.metaKey)) {
          (_b = callbacks.onDoubleClickShape) == null ? void 0 : _b.call(callbacks, info, e2);
        }
        (_c = callbacks.onReleaseShape) == null ? void 0 : _c.call(callbacks, info, e2);
      }
      (_d = callbacks.onPointerUp) == null ? void 0 : _d.call(callbacks, info, e2);
    },
    onPointerMove: (e2) => {
      var _a, _b;
      if (e2.dead)
        return;
      else
        e2.dead = true;
      if (e2.buttons === 2 || !inputs2.pointerIsValid(e2) || inputs2.pointer && e2.pointerId !== inputs2.pointer.pointerId) {
        return;
      }
      const info = inputs2.pointerMove(e2, id);
      if (e2.buttons === 1 && e2.currentTarget.hasPointerCapture(e2.pointerId)) {
        (_a = callbacks.onDragShape) == null ? void 0 : _a.call(callbacks, info, e2);
      }
      (_b = callbacks.onPointerMove) == null ? void 0 : _b.call(callbacks, info, e2);
    },
    onPointerEnter: (e2) => {
      var _a;
      if (!inputs2.pointerIsValid(e2))
        return;
      const info = inputs2.pointerEnter(e2, id);
      (_a = callbacks.onHoverShape) == null ? void 0 : _a.call(callbacks, info, e2);
    },
    onPointerLeave: (e2) => {
      var _a;
      if (!inputs2.pointerIsValid(e2))
        return;
      const info = inputs2.pointerEnter(e2, id);
      (_a = callbacks.onUnhoverShape) == null ? void 0 : _a.call(callbacks, info, e2);
    }
  }), [inputs2, callbacks, id]);
}
function addToShapeTree(shape, branch, shapes, pageState, assets, isChildOfGhost = false, isChildOfSelected = false, meta, bindingTargetId) {
  const node = {
    shape,
    asset: shape.assetId ? assets[shape.assetId] : void 0,
    meta,
    isChildOfSelected,
    isGhost: shape.isGhost || isChildOfGhost,
    isEditing: pageState.editingId === shape.id,
    isBinding: bindingTargetId === shape.id,
    isSelected: pageState.selectedIds.includes(shape.id),
    isHovered: pageState.hoveredId === shape.id || shape.children !== void 0 && (pageState.hoveredId && shape.children.includes(pageState.hoveredId) || shape.children.some((childId) => pageState.selectedIds.includes(childId)))
  };
  branch.push(node);
  if (shape.children) {
    node.children = [];
    shape.children.map((id) => shapes[id]).filter((childShape) => shapes[childShape.id]).sort((a, b) => a.childIndex - b.childIndex).forEach((childShape) => addToShapeTree(childShape, node.children, shapes, pageState, assets, node.isGhost, node.isSelected || node.isChildOfSelected, meta));
  }
}
function shapeIsInViewport(bounds, viewport) {
  return Utils.boundsContain(viewport, bounds) || Utils.boundsCollide(viewport, bounds);
}
function useShapeTree(page, pageState, assets, meta) {
  const { callbacks, shapeUtils, bounds } = useTLContext();
  const rTimeout = React5.useRef();
  const rPreviousCount = React5.useRef(-1);
  const rShapesIdsToRender = React5.useRef(/* @__PURE__ */ new Set());
  const rShapesToRender = React5.useRef(/* @__PURE__ */ new Set());
  const { selectedIds, camera } = pageState;
  const [minX, minY] = e.sub(e.div([0, 0], camera.zoom), camera.point);
  const [maxX, maxY] = e.sub(e.div([bounds.width, bounds.height], camera.zoom), camera.point);
  const viewport = {
    minX,
    minY,
    maxX,
    maxY,
    height: maxX - minX,
    width: maxY - minY
  };
  const shapesToRender = rShapesToRender.current;
  const shapesIdsToRender = rShapesIdsToRender.current;
  shapesToRender.clear();
  shapesIdsToRender.clear();
  const allShapes = Object.values(page.shapes);
  allShapes.filter((shape) => shapeUtils[shape.type].isStateful || selectedIds.includes(shape.id) || shapeIsInViewport(shapeUtils[shape.type].getBounds(shape), viewport)).forEach((shape) => {
    if (shape.parentId === page.id) {
      shapesIdsToRender.add(shape.id);
      shapesToRender.add(shape);
      return;
    }
    const parent = page.shapes[shape.parentId];
    if (parent === void 0) {
      throw Error(`A shape (${shape.id}) has a parent (${shape.parentId}) that does not exist!`);
    } else {
      shapesIdsToRender.add(parent.id);
      shapesToRender.add(parent);
    }
  });
  if (shapesToRender.size !== rPreviousCount.current) {
    if (rTimeout.current) {
      clearTimeout(rTimeout.current);
    }
    rTimeout.current = requestAnimationFrame(() => {
      var _a;
      (_a = callbacks.onRenderCountChange) == null ? void 0 : _a.call(callbacks, Array.from(shapesIdsToRender.values()));
    });
    rPreviousCount.current = shapesToRender.size;
  }
  const bindingTargetId = pageState.bindingId ? page.bindings[pageState.bindingId].toId : void 0;
  const tree = [];
  shapesToRender.forEach((shape) => {
    if (shape === void 0) {
      throw Error("Rendered shapes included a missing shape");
    }
    addToShapeTree(shape, tree, page.shapes, pageState, assets, shape.isGhost, false, meta, bindingTargetId);
  });
  tree.sort((a, b) => a.shape.childIndex - b.shape.childIndex);
  return tree;
}
var styles = /* @__PURE__ */ new Map();
function makeCssTheme(prefix, theme) {
  return Object.keys(theme).reduce((acc, key) => {
    const value = theme[key];
    if (value) {
      return acc + `${`--${prefix}-${key}`}: ${value};
`;
    }
    return acc;
  }, "");
}
function useTheme(prefix, theme, selector = ":root") {
  React6.useLayoutEffect(() => {
    const style = document.createElement("style");
    const cssTheme = makeCssTheme(prefix, theme);
    style.setAttribute("id", `${prefix}-theme`);
    style.setAttribute("data-selector", selector);
    style.innerHTML = `
        ${selector} {
          ${cssTheme}
        }
      `;
    document.head.appendChild(style);
    return () => {
      if (style && document.head.contains(style)) {
        document.head.removeChild(style);
      }
    };
  }, [prefix, theme, selector]);
}
function useStyle(uid, rules) {
  React6.useLayoutEffect(() => {
    if (styles.get(uid)) {
      return () => void 0;
    }
    const style = document.createElement("style");
    style.innerHTML = rules;
    style.setAttribute("id", uid);
    document.head.appendChild(style);
    styles.set(uid, style);
    return () => {
      if (style && document.head.contains(style)) {
        document.head.removeChild(style);
        styles.delete(uid);
      }
    };
  }, [uid, rules]);
}
var css = (strings, ...args) => strings.reduce((acc, string, index) => acc + string + (index < args.length ? args[index] : ""), "");
var defaultTheme = {
  accent: "rgb(255, 0, 0)",
  brushFill: "rgba(0,0,0,.05)",
  brushStroke: "rgba(0,0,0,.25)",
  brushDashStroke: "rgba(0,0,0,.6)",
  selectStroke: "rgb(66, 133, 244)",
  selectFill: "rgba(65, 132, 244, 0.05)",
  binding: "rgba(65, 132, 244, 0.12)",
  background: "rgb(248, 249, 250)",
  foreground: "rgb(51, 51, 51)",
  grid: "rgba(144, 144, 144, 1)"
};
var TLCSS = css`
  .tl-container {
    --tl-zoom: 1;
    --tl-scale: calc(1 / var(--tl-zoom));
    --tl-padding: calc(64px * max(1, var(--tl-scale)));
    --tl-performance-all: auto;
    --tl-performance-selected: auto;
    position: relative;
    top: 0px;
    left: 0px;
    width: 100%;
    height: 100%;
    max-width: 100%;
    max-height: 100%;
    box-sizing: border-box;
    padding: 0px;
    margin: 0px;
    z-index: 100;
    overflow: hidden;
    touch-action: none;
    overscroll-behavior: none;
    background-color: var(--tl-background);
  }
  .tl-container * {
    box-sizing: border-box;
  }
  .tl-overlay {
    position: absolute;
    width: 100%;
    height: 100%;
    touch-action: none;
    pointer-events: none;
  }
  .tl-grid {
    position: absolute;
    width: 100%;
    height: 100%;
    touch-action: none;
    pointer-events: none;
    user-select: none;
  }
  .tl-snap-line {
    stroke: var(--tl-accent);
    stroke-width: calc(1px * var(--tl-scale));
  }
  .tl-snap-point {
    stroke: var(--tl-accent);
    stroke-width: calc(1px * var(--tl-scale));
  }
  .tl-canvas {
    position: absolute;
    width: 100%;
    height: 100%;
    touch-action: none;
    pointer-events: all;
    overflow: clip;
  }
  .tl-layer {
    position: absolute;
    top: 0px;
    left: 0px;
    height: 0px;
    width: 0px;
    contain: layout style size;
  }
  .tl-absolute {
    position: absolute;
    top: 0px;
    left: 0px;
    transform-origin: center center;
    contain: layout style size;
  }
  .tl-positioned {
    position: absolute;
    top: 0px;
    left: 0px;
    transform-origin: center center;
    pointer-events: none;
    display: flex;
    align-items: center;
    justify-content: center;
    contain: layout style size;
    will-change: var(--tl-performance-all);
  }
  .tl-positioned-svg {
    width: 100%;
    height: 100%;
    overflow: hidden;
    contain: layout style size;
  }
  .tl-positioned-div {
    position: relative;
    width: 100%;
    height: 100%;
    overflow: hidden;
    padding: var(--tl-padding);
    overflow: hidden;
    contain: layout style size;
  }
  .tl-positioned-selected {
    will-change: var(--tl-performance-selected);
  }
  .tl-inner-div {
    position: relative;
    width: 100%;
    height: 100%;
  }
  .tl-stroke-hitarea {
    fill: none;
    stroke: transparent;
    stroke-width: calc(24px * var(--tl-scale));
    pointer-events: stroke;
    stroke-linecap: round;
    stroke-linejoin: round;
  }
  .tl-fill-hitarea {
    fill: transparent;
    stroke: transparent;
    stroke-width: calc(24px * var(--tl-scale));
    pointer-events: all;
    stroke-linecap: round;
    stroke-linejoin: round;
  }
  .tl-counter-scaled {
    transform: scale(var(--tl-scale));
  }
  .tl-dashed {
    stroke-dasharray: calc(2px * var(--tl-scale)), calc(2px * var(--tl-scale));
  }
  .tl-transparent {
    fill: transparent;
    stroke: transparent;
  }
  .tl-cursor-ns {
    cursor: ns-resize;
  }
  .tl-cursor-ew {
    cursor: ew-resize;
  }
  .tl-cursor-nesw {
    cursor: nesw-resize;
  }
  .tl-cursor-nwse {
    cursor: nwse-resize;
  }
  .tl-corner-handle {
    stroke: var(--tl-selectStroke);
    fill: var(--tl-background);
    stroke-width: calc(1.5px * var(--tl-scale));
  }
  .tl-rotate-handle {
    stroke: var(--tl-selectStroke);
    fill: var(--tl-background);
    stroke-width: calc(1.5px * var(--tl-scale));
    cursor: grab;
  }
  .tl-binding {
    fill: var(--tl-selectFill);
    stroke: var(--tl-selectStroke);
    stroke-width: calc(1px * var(--tl-scale));
    pointer-events: none;
  }
  .tl-user {
    left: calc(-15px * var(--tl-scale));
    top: calc(-15px * var(--tl-scale));
    height: calc(35px * var(--tl-scale));
    width: calc(35px * var(--tl-scale));
    transform: scale(var(--tl-scale));
    pointer-events: none;
    will-change: transform;
  }
  .tl-animated {
    transition: transform 200ms linear;
  }
  .tl-indicator {
    fill: transparent;
    stroke-width: calc(1.5px * var(--tl-scale));
    pointer-events: none;
  }
  .tl-user-indicator-bounds {
    border-style: solid;
    border-width: calc(1px * var(--tl-scale));
  }
  .tl-hovered {
    stroke: var(--tl-selectStroke);
  }
  .tl-selected {
    stroke: var(--tl-selectStroke);
  }
  .tl-locked {
    stroke-dasharray: calc(3px * var(--tl-scale)) calc(3px * var(--tl-scale));
  }
  .tl-editing {
    stroke-width: calc(2.5px * min(5, var(--tl-scale)));
  }
  .tl-performance {
    will-change: transform, contents;
  }
  .tl-clone-target {
    pointer-events: all;
  }
  .tl-clone-target:hover .tl-clone-button {
    opacity: 1;
  }
  .tl-clone-button-target {
    cursor: pointer;
    pointer-events: all;
  }
  .tl-clone-button-target:hover .tl-clone-button {
    fill: var(--tl-selectStroke);
  }
  .tl-clone-button {
    opacity: 0;
    r: calc(8px * var(--tl-scale));
    stroke-width: calc(1.5px * var(--tl-scale));
    stroke: var(--tl-selectStroke);
    fill: var(--tl-background);
  }
  .tl-bounds {
    pointer-events: none;
    contain: layout style size;
  }
  .tl-bounds-bg {
    stroke: none;
    fill: var(--tl-selectFill);
    pointer-events: all;
    contain: layout style size;
  }
  .tl-bounds-center {
    fill: transparent;
    stroke: var(--tl-selectStroke);
    stroke-width: calc(1.5px * var(--tl-scale));
  }
  .tl-brush {
    fill: var(--tl-brushFill);
    stroke: var(--tl-brushStroke);
    stroke-width: calc(1px * var(--tl-scale));
    pointer-events: none;
    contain: layout style size;
  }
  .tl-dashed-brush-line {
    fill: none;
    stroke: var(--tl-brushDashStroke);
    stroke-width: calc(1px * var(--tl-scale));
    pointer-events: none;
  }
  .tl-brush.dashed {
    stroke: none;
  }
  .tl-handle {
    pointer-events: all;
    cursor: grab;
  }
  .tl-handle:hover .tl-handle-bg {
    fill: var(--tl-selectFill);
  }
  .tl-handle:hover .tl-handle-bg > * {
    stroke: var(--tl-selectFill);
  }
  .tl-handle:active .tl-handle-bg {
    cursor: grabbing;
    fill: var(--tl-selectFill);
  }
  .tl-handle:active .tl-handle-bg > * {
    stroke: var(--tl-selectFill);
  }
  .tl-handle {
    fill: var(--tl-background);
    stroke: var(--tl-selectStroke);
    stroke-width: 1.5px;
  }
  .tl-handle-bg {
    fill: transparent;
    stroke: none;
    pointer-events: all;
    r: calc(16px / max(1, var(--tl-zoom)));
  }
  .tl-binding-indicator {
    fill: transparent;
    stroke: var(--tl-binding);
  }
  .tl-centered-g {
    transform: translate(var(--tl-padding), var(--tl-padding));
  }
  .tl-current-parent > *[data-shy='true'] {
    opacity: 1;
  }
  .tl-binding {
    fill: none;
    stroke: var(--tl-selectStroke);
    stroke-width: calc(2px * var(--tl-scale));
  }
  .tl-grid-dot {
    fill: var(--tl-grid);
  }
  .tl-erase-line {
    stroke-linejoin: round;
    stroke-linecap: round;
    pointer-events: none;
    fill: var(--tl-grid);
    opacity: 0.32;
  }
`;
function useTLTheme(theme, selector) {
  const tltheme = React6.useMemo(() => __spreadValues(__spreadValues({}, defaultTheme), theme), [theme]);
  useTheme("tl", tltheme, selector);
  useStyle("tl-canvas", TLCSS);
}
function useBoundsHandleEvents(id) {
  const { callbacks, inputs: inputs2 } = useTLContext();
  const onPointerDown = React7.useCallback((e2) => {
    var _a, _b, _c;
    if (e2.dead)
      return;
    else
      e2.dead = true;
    if (!inputs2.pointerIsValid(e2))
      return;
    const info = inputs2.pointerDown(e2, id);
    if (e2.button === 2) {
      (_a = callbacks.onRightPointBoundsHandle) == null ? void 0 : _a.call(callbacks, info, e2);
      return;
    }
    if (e2.button === 0) {
      (_b = callbacks.onPointBoundsHandle) == null ? void 0 : _b.call(callbacks, info, e2);
    }
    (_c = callbacks.onPointerDown) == null ? void 0 : _c.call(callbacks, info, e2);
  }, [inputs2, callbacks, id]);
  const onPointerUp = React7.useCallback((e2) => {
    var _a, _b, _c;
    if (e2.dead)
      return;
    else
      e2.dead = true;
    if (e2.button === 2 || !inputs2.pointerIsValid(e2))
      return;
    const info = inputs2.pointerUp(e2, id);
    const isDoubleClick = inputs2.isDoubleClick();
    if (e2.button === 0) {
      if (isDoubleClick && !(info.altKey || info.metaKey)) {
        (_a = callbacks.onDoubleClickBoundsHandle) == null ? void 0 : _a.call(callbacks, info, e2);
      }
      (_b = callbacks.onReleaseBoundsHandle) == null ? void 0 : _b.call(callbacks, info, e2);
    }
    (_c = callbacks.onPointerUp) == null ? void 0 : _c.call(callbacks, info, e2);
  }, [inputs2, callbacks, id]);
  const onPointerMove = React7.useCallback((e2) => {
    var _a, _b;
    if (e2.dead)
      return;
    else
      e2.dead = true;
    if (!inputs2.pointerIsValid(e2))
      return;
    if (e2.buttons === 2) {
      return;
    }
    const info = inputs2.pointerMove(e2, id);
    if (e2.buttons === 1) {
      if (e2.currentTarget.hasPointerCapture(e2.pointerId)) {
        (_a = callbacks.onDragBoundsHandle) == null ? void 0 : _a.call(callbacks, info, e2);
      }
    }
    (_b = callbacks.onPointerMove) == null ? void 0 : _b.call(callbacks, info, e2);
  }, [inputs2, callbacks, id]);
  const onPointerEnter = React7.useCallback((e2) => {
    var _a;
    if (!inputs2.pointerIsValid(e2))
      return;
    (_a = callbacks.onHoverBoundsHandle) == null ? void 0 : _a.call(callbacks, inputs2.pointerEnter(e2, id), e2);
  }, [inputs2, callbacks, id]);
  const onPointerLeave = React7.useCallback((e2) => {
    var _a;
    if (!inputs2.pointerIsValid(e2))
      return;
    (_a = callbacks.onUnhoverBoundsHandle) == null ? void 0 : _a.call(callbacks, inputs2.pointerEnter(e2, id), e2);
  }, [inputs2, callbacks, id]);
  return {
    onPointerDown,
    onPointerUp,
    onPointerEnter,
    onPointerMove,
    onPointerLeave
  };
}
function useCameraCss(layerRef, containerRef, pageState) {
  const rZoom = React8.useRef();
  const rPoint = React8.useRef();
  React8.useLayoutEffect(() => {
    const { zoom, point } = pageState.camera;
    const didZoom = zoom !== rZoom.current;
    const didPan = point !== rPoint.current;
    rZoom.current = zoom;
    rPoint.current = point;
    if (didZoom || didPan) {
      const layer = layerRef.current;
      if (containerRef && "current" in containerRef) {
        const container = containerRef.current;
        if (didZoom) {
          if (container) {
            container.style.setProperty("--tl-zoom", zoom.toString());
          }
        }
        if (layer) {
          layer.style.setProperty("transform", `scale(${zoom}) translateX(${point[0]}px) translateY(${point[1]}px)`);
        }
      }
    }
  }, [pageState.camera.zoom, pageState.camera.point]);
}
function canvasToScreen(point, camera) {
  return [(point[0] + camera.point[0]) * camera.zoom, (point[1] + camera.point[1]) * camera.zoom];
}
function getShapeUtils(shapeUtils, shape) {
  return shapeUtils[shape.type];
}
function useSelection(page, pageState, shapeUtils) {
  const { rSelectionBounds } = useTLContext();
  const { selectedIds } = pageState;
  const rPrevBounds = React9.useRef();
  let bounds = void 0;
  let rotation = 0;
  let isLocked = false;
  let isLinked = false;
  if (selectedIds.length === 1) {
    const id = selectedIds[0];
    const shape = page.shapes[id];
    if (!shape) {
      throw Error(`selectedIds is set to the id of a shape that doesn't exist: ${id}`);
    }
    rotation = shape.rotation || 0;
    isLocked = shape.isLocked || false;
    const utils = getShapeUtils(shapeUtils, shape);
    bounds = utils.hideBounds ? void 0 : utils.getBounds(shape);
  } else if (selectedIds.length > 1) {
    const selectedShapes = selectedIds.map((id) => page.shapes[id]);
    rotation = 0;
    isLocked = selectedShapes.every((shape) => shape.isLocked);
    bounds = selectedShapes.reduce((acc, shape, i) => {
      if (i === 0) {
        return getShapeUtils(shapeUtils, shape).getRotatedBounds(shape);
      }
      return utils_default.getExpandedBounds(acc, getShapeUtils(shapeUtils, shape).getRotatedBounds(shape));
    }, {});
  }
  if (bounds) {
    const [minX, minY] = canvasToScreen([bounds.minX, bounds.minY], pageState.camera);
    const [maxX, maxY] = canvasToScreen([bounds.maxX, bounds.maxY], pageState.camera);
    isLinked = !!Object.values(page.bindings).find((binding) => selectedIds.includes(binding.toId) || selectedIds.includes(binding.fromId));
    rSelectionBounds.current = {
      minX,
      minY,
      maxX,
      maxY,
      width: maxX - minX,
      height: maxY - minY
    };
  } else {
    rSelectionBounds.current = null;
  }
  const prevBounds = rPrevBounds.current;
  if (!prevBounds || !bounds) {
    rPrevBounds.current = bounds;
  } else if (bounds) {
    if (prevBounds.minX === bounds.minX && prevBounds.minY === bounds.minY && prevBounds.maxX === bounds.maxX && prevBounds.maxY === bounds.maxY) {
      bounds = rPrevBounds.current;
    }
  }
  return { bounds, rotation, isLocked, isLinked };
}
function useHandleEvents(id) {
  const { inputs: inputs2, callbacks } = useTLContext();
  return React10.useMemo(() => {
    return {
      onPointerDown: (e2) => {
        var _a, _b, _c;
        if (e2.dead)
          return;
        else
          e2.dead = true;
        if (!inputs2.pointerIsValid(e2))
          return;
        if (e2.button === 2) {
          return;
        }
        (_a = e2.currentTarget) == null ? void 0 : _a.setPointerCapture(e2.pointerId);
        const info = inputs2.pointerDown(e2, id);
        if (e2.button === 0) {
          (_b = callbacks.onPointHandle) == null ? void 0 : _b.call(callbacks, info, e2);
        }
        (_c = callbacks.onPointerDown) == null ? void 0 : _c.call(callbacks, info, e2);
      },
      onPointerUp: (e2) => {
        var _a, _b, _c, _d;
        if (e2.dead)
          return;
        else
          e2.dead = true;
        if (!inputs2.pointerIsValid(e2))
          return;
        if (e2.button === 2) {
          return;
        }
        const isDoubleClick = inputs2.isDoubleClick();
        const info = inputs2.pointerUp(e2, id);
        if (e2.currentTarget.hasPointerCapture(e2.pointerId)) {
          (_a = e2.currentTarget) == null ? void 0 : _a.releasePointerCapture(e2.pointerId);
          if (e2.button === 0) {
            if (isDoubleClick && !(info.altKey || info.metaKey)) {
              (_b = callbacks.onDoubleClickHandle) == null ? void 0 : _b.call(callbacks, info, e2);
            }
            (_c = callbacks.onReleaseHandle) == null ? void 0 : _c.call(callbacks, info, e2);
          }
        }
        (_d = callbacks.onPointerUp) == null ? void 0 : _d.call(callbacks, info, e2);
      },
      onPointerMove: (e2) => {
        var _a, _b;
        if (e2.dead)
          return;
        else
          e2.dead = true;
        if (!inputs2.pointerIsValid(e2))
          return;
        if (e2.buttons === 2) {
          return;
        }
        const info = inputs2.pointerMove(e2, id);
        if (e2.buttons === 1) {
          if (e2.currentTarget.hasPointerCapture(e2.pointerId)) {
            (_a = callbacks.onDragHandle) == null ? void 0 : _a.call(callbacks, info, e2);
          }
        }
        (_b = callbacks.onPointerMove) == null ? void 0 : _b.call(callbacks, info, e2);
      },
      onPointerEnter: (e2) => {
        var _a;
        if (!inputs2.pointerIsValid(e2))
          return;
        const info = inputs2.pointerEnter(e2, id);
        (_a = callbacks.onHoverHandle) == null ? void 0 : _a.call(callbacks, info, e2);
      },
      onPointerLeave: (e2) => {
        var _a;
        if (!inputs2.pointerIsValid(e2))
          return;
        const info = inputs2.pointerEnter(e2, id);
        (_a = callbacks.onUnhoverHandle) == null ? void 0 : _a.call(callbacks, info, e2);
      }
    };
  }, [inputs2, callbacks, id]);
}
function usePreventNavigationCss(rCanvas) {
  const { bounds } = useTLContext();
  React11.useEffect(() => {
    const preventGestureNavigation = (event) => {
      event.preventDefault();
    };
    const preventNavigation = (event) => {
      const touchXPosition = event.touches[0].pageX;
      const touchXRadius = event.touches[0].radiusX || 0;
      if (touchXPosition - touchXRadius < 10 || touchXPosition + touchXRadius > bounds.width - 10) {
        event.preventDefault();
      }
    };
    const elm = rCanvas.current;
    if (!elm)
      return () => void 0;
    elm.addEventListener("gestureend", preventGestureNavigation);
    elm.addEventListener("gesturechange", preventGestureNavigation);
    elm.addEventListener("gesturestart", preventGestureNavigation);
    elm.addEventListener("touchstart", preventNavigation);
    return () => {
      if (elm) {
        elm.removeEventListener("gestureend", preventGestureNavigation);
        elm.removeEventListener("gesturechange", preventGestureNavigation);
        elm.removeEventListener("gesturestart", preventGestureNavigation);
        elm.removeEventListener("touchstart", preventNavigation);
      }
    };
  }, [rCanvas, bounds.width]);
}
function useBoundsEvents() {
  const { callbacks, inputs: inputs2 } = useTLContext();
  return React12.useMemo(() => {
    return {
      onPointerDown: (e2) => {
        var _a, _b, _c, _d;
        if (e2.dead)
          return;
        else
          e2.dead = true;
        if (!inputs2.pointerIsValid(e2))
          return;
        if (e2.button === 2) {
          (_a = callbacks.onRightPointBounds) == null ? void 0 : _a.call(callbacks, inputs2.pointerDown(e2, "bounds"), e2);
          return;
        }
        const info = inputs2.pointerDown(e2, "bounds");
        (_b = e2.currentTarget) == null ? void 0 : _b.setPointerCapture(e2.pointerId);
        if (e2.button === 0) {
          (_c = callbacks.onPointBounds) == null ? void 0 : _c.call(callbacks, info, e2);
        }
        (_d = callbacks.onPointerDown) == null ? void 0 : _d.call(callbacks, info, e2);
      },
      onPointerUp: (e2) => {
        var _a, _b, _c, _d;
        if (e2.dead)
          return;
        else
          e2.dead = true;
        if (e2.button === 2) {
          return;
        }
        inputs2.activePointer = void 0;
        if (!inputs2.pointerIsValid(e2))
          return;
        const isDoubleClick = inputs2.isDoubleClick();
        const info = inputs2.pointerUp(e2, "bounds");
        if (e2.currentTarget.hasPointerCapture(e2.pointerId)) {
          (_a = e2.currentTarget) == null ? void 0 : _a.releasePointerCapture(e2.pointerId);
        }
        if (e2.button === 0) {
          if (isDoubleClick && !(info.altKey || info.metaKey)) {
            (_b = callbacks.onDoubleClickBounds) == null ? void 0 : _b.call(callbacks, info, e2);
          }
          (_c = callbacks.onReleaseBounds) == null ? void 0 : _c.call(callbacks, info, e2);
        }
        (_d = callbacks.onPointerUp) == null ? void 0 : _d.call(callbacks, info, e2);
      },
      onPointerMove: (e2) => {
        var _a, _b;
        if (e2.dead)
          return;
        else
          e2.dead = true;
        if (!inputs2.pointerIsValid(e2))
          return;
        if (e2.buttons === 1) {
          if (e2.currentTarget.hasPointerCapture(e2.pointerId)) {
            (_a = callbacks.onDragBounds) == null ? void 0 : _a.call(callbacks, inputs2.pointerMove(e2, "bounds"), e2);
          }
        }
        const info = inputs2.pointerMove(e2, "bounds");
        (_b = callbacks.onPointerMove) == null ? void 0 : _b.call(callbacks, info, e2);
      },
      onPointerEnter: (e2) => {
        var _a;
        if (!inputs2.pointerIsValid(e2))
          return;
        (_a = callbacks.onHoverBounds) == null ? void 0 : _a.call(callbacks, inputs2.pointerEnter(e2, "bounds"), e2);
      },
      onPointerLeave: (e2) => {
        var _a;
        if (!inputs2.pointerIsValid(e2))
          return;
        (_a = callbacks.onUnhoverBounds) == null ? void 0 : _a.call(callbacks, inputs2.pointerEnter(e2, "bounds"), e2);
      }
    };
  }, [inputs2, callbacks]);
}
function usePosition(bounds, rotation = 0) {
  const rBounds = React13.useRef(null);
  React13.useLayoutEffect(() => {
    const elm = rBounds.current;
    const transform = `
    translate(
      calc(${bounds.minX}px - var(--tl-padding)),
      calc(${bounds.minY}px - var(--tl-padding))
    )
    rotate(${rotation + (bounds.rotation || 0)}rad)`;
    elm.style.setProperty("transform", transform);
    elm.style.setProperty("width", `calc(${Math.floor(bounds.width)}px + (var(--tl-padding) * 2))`);
    elm.style.setProperty("height", `calc(${Math.floor(bounds.height)}px + (var(--tl-padding) * 2))`);
  }, [bounds, rotation]);
  return rBounds;
}
function useKeyEvents() {
  const { inputs: inputs2, callbacks } = useTLContext();
  React14.useEffect(() => {
    const handleKeyDown = (e2) => {
      var _a;
      (_a = callbacks.onKeyDown) == null ? void 0 : _a.call(callbacks, e2.key, inputs2.keydown(e2), e2);
    };
    const handleKeyUp = (e2) => {
      var _a;
      inputs2.keyup(e2);
      (_a = callbacks.onKeyUp) == null ? void 0 : _a.call(callbacks, e2.key, inputs2.keyup(e2), e2);
    };
    window.addEventListener("keydown", handleKeyDown);
    window.addEventListener("keyup", handleKeyUp);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
    };
  }, [inputs2, callbacks]);
}
function usePerformanceCss(performanceMode, rContainer) {
  React15.useLayoutEffect(() => {
    if (rContainer && "current" in rContainer) {
      const container = rContainer == null ? void 0 : rContainer.current;
      if (!container)
        return;
      switch (performanceMode) {
        case "transform_selected": {
          container.style.setProperty("--tl-performance-all", "auto");
          container.style.setProperty("--tl-performance-selected", "transform, contents");
          break;
        }
        case "transform_all": {
          container.style.setProperty("--tl-performance-all", "transform, contents");
          container.style.setProperty("--tl-performance-selected", "transform, contents");
          break;
        }
        case "translate_selected": {
          container.style.setProperty("--tl-performance-all", "auto");
          container.style.setProperty("--tl-performance-selected", "transform");
          break;
        }
        case "translate_all": {
          container.style.setProperty("--tl-performance-all", "transform");
          container.style.setProperty("--tl-performance-selected", "transform");
          break;
        }
        default: {
          container.style.setProperty("--tl-performance-all", "auto");
          container.style.setProperty("--tl-performance-selected", "auto");
        }
      }
    }
  }, [performanceMode]);
}
function _Container(_a) {
  var _b = _a, {
    id,
    bounds,
    rotation = 0,
    isGhost = false,
    isSelected = false,
    children
  } = _b, props = __objRest(_b, [
    "id",
    "bounds",
    "rotation",
    "isGhost",
    "isSelected",
    "children"
  ]);
  const rPositioned = usePosition(bounds, rotation);
  return React16.createElement("div", __spreadValues({
    id,
    ref: rPositioned,
    className: `tl-positioned${isGhost ? " tl-ghost" : ""}${isSelected ? ` tl-positioned-selected` : ""}`,
    "aria-label": "container",
    "data-testid": "container"
  }, props), children);
}
var Container = React16.memo(_Container);
function _Brush({ brush, zoom, dashed }) {
  return React17.createElement(Container, {
    bounds: brush,
    rotation: 0
  }, React17.createElement(SVGContainer, null, React17.createElement("rect", {
    className: "tl-brush" + (dashed ? " dashed" : ""),
    opacity: 1,
    x: 0,
    y: 0,
    width: brush.width,
    height: brush.height,
    "aria-label": "brush"
  }), dashed && React17.createElement("g", {
    className: "tl-dashed-brush-line"
  }, React17.createElement(PerfectDashLine, {
    x1: 0,
    y1: 0,
    x2: brush.width,
    y2: 0,
    zoom
  }), React17.createElement(PerfectDashLine, {
    x1: brush.width,
    y1: 0,
    x2: brush.width,
    y2: brush.height,
    zoom
  }), React17.createElement(PerfectDashLine, {
    x1: 0,
    y1: brush.height,
    x2: brush.width,
    y2: brush.height,
    zoom
  }), React17.createElement(PerfectDashLine, {
    x1: 0,
    y1: 0,
    x2: 0,
    y2: brush.height,
    zoom
  }))));
}
var Brush = React17.memo(_Brush);
function PerfectDashLine({ x1, y1, x2, y2, zoom }) {
  const dash = utils_default.getPerfectDashProps(Math.hypot(x2 - x1, y2 - y1), 1 / zoom, "dashed", 1, true, 3);
  return React17.createElement("line", {
    x1,
    y1,
    x2,
    y2,
    strokeWidth: 1 / zoom,
    strokeDasharray: dash.strokeDasharray,
    strokeDashoffset: dash.strokeDashoffset
  });
}
var Cursor = React18.memo(({ color }) => {
  return React18.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 35 35",
    fill: "none",
    fillRule: "evenodd"
  }, React18.createElement("g", {
    fill: "rgba(0,0,0,.2)",
    transform: "translate(1,1)"
  }, React18.createElement("path", {
    d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z"
  }), React18.createElement("path", {
    d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z"
  })), React18.createElement("g", {
    fill: "white"
  }, React18.createElement("path", {
    d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z"
  }), React18.createElement("path", {
    d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z"
  })), React18.createElement("g", {
    fill: color
  }, React18.createElement("path", {
    d: "m19.751 24.4155-1.844.774-3.1-7.374 1.841-.775z"
  }), React18.createElement("path", {
    d: "m13 10.814v11.188l2.969-2.866.428-.139h4.768z"
  })));
});
function _EraseLine({ points, zoom }) {
  if (points.length === 0)
    return null;
  const d = utils_default.getSvgPathFromStroke(_e(points, { size: 16 / zoom, start: { taper: true } }));
  return React19.createElement("path", {
    d,
    className: "tl-erase-line"
  });
}
var EraseLine = React19.memo(_EraseLine);
var STEPS = [
  [-1, 0.15, 64],
  [0.05, 0.375, 16],
  [0.15, 1, 4],
  [0.7, 2.5, 1]
];
function Grid({ grid, camera }) {
  return React20.createElement("svg", {
    className: "tl-grid",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg"
  }, React20.createElement("defs", null, STEPS.map(([min, mid, size], i) => {
    const s = size * grid * camera.zoom;
    const xo = camera.point[0] * camera.zoom;
    const yo = camera.point[1] * camera.zoom;
    const gxo = xo > 0 ? xo % s : s + xo % s;
    const gyo = yo > 0 ? yo % s : s + yo % s;
    const opacity = camera.zoom < mid ? utils_default.modulate(camera.zoom, [min, mid], [0, 1]) : 1;
    return React20.createElement("pattern", {
      key: `grid-pattern-${i}`,
      id: `grid-${i}`,
      width: s,
      height: s,
      patternUnits: "userSpaceOnUse"
    }, React20.createElement("circle", {
      className: `tl-grid-dot`,
      cx: gxo,
      cy: gyo,
      r: 1,
      opacity
    }));
  })), STEPS.map((_, i) => React20.createElement("rect", {
    key: `grid-rect-${i}`,
    width: "100%",
    height: "100%",
    fill: `url(#grid-${i})`
  })));
}
function _Overlay({ camera: { zoom, point }, children }) {
  const l = 2.5 / zoom;
  return React21.createElement("svg", {
    className: "tl-overlay"
  }, React21.createElement("defs", null, React21.createElement("g", {
    id: "tl-snap-point"
  }, React21.createElement("path", {
    className: "tl-snap-point",
    d: `M ${-l},${-l} L ${l},${l} M ${-l},${l} L ${l},${-l}`
  }))), React21.createElement("g", {
    transform: `scale(${zoom}) translate(${point})`
  }, children));
}
var Overlay = React21.memo(_Overlay);
var SVGContainer = React222.memo(React222.forwardRef(function SVGContainer2(_a, ref) {
  var _b = _a, { id, className = "", children } = _b, rest = __objRest(_b, ["id", "className", "children"]);
  return React222.createElement("svg", __spreadValues({
    ref,
    className: `tl-positioned-svg ${className}`
  }, rest), React222.createElement("g", {
    id,
    className: "tl-centered-g"
  }, children));
}));
function _CenterHandle({ bounds, isLocked, isHidden }) {
  return React23.createElement("rect", {
    className: ["tl-bounds-center", isLocked ? "tl-dashed" : ""].join(" "),
    x: -1,
    y: -1,
    width: bounds.width + 2,
    height: bounds.height + 2,
    opacity: isHidden ? 0 : 1,
    pointerEvents: "none",
    "aria-label": "center handle"
  });
}
var CenterHandle = React23.memo(_CenterHandle);
var ROTATIONS = {
  right: 0,
  bottomRight: 45,
  bottom: 90,
  bottomLeft: 135,
  left: 180,
  topLeft: 225,
  top: 270,
  topRight: 315
};
function _CloneButton({ bounds, side, targetSize, size }) {
  const s = targetSize * 2;
  const x = {
    left: -s,
    topLeft: -s,
    bottomLeft: -s,
    right: bounds.width,
    topRight: bounds.width,
    bottomRight: bounds.width,
    top: bounds.width / 2 - s / 2,
    bottom: bounds.width / 2 - s / 2
  }[side];
  const y = {
    left: bounds.height / 2 - s / 2,
    right: bounds.height / 2 - s / 2,
    top: -s * 2,
    topLeft: -s,
    topRight: -s,
    bottom: bounds.height,
    bottomLeft: bounds.height,
    bottomRight: bounds.height
  }[side];
  const { callbacks, inputs: inputs2 } = useTLContext();
  const handleClick = React24.useCallback((e2) => {
    var _a;
    e2.stopPropagation();
    const info = inputs2.pointerDown(e2, side);
    (_a = callbacks.onShapeClone) == null ? void 0 : _a.call(callbacks, info, e2);
  }, [callbacks.onShapeClone]);
  return React24.createElement("g", {
    className: "tl-clone-target",
    transform: `translate(${x}, ${y})`,
    "aria-label": "clone button"
  }, React24.createElement("rect", {
    className: "tl-transparent",
    width: targetSize * 2,
    height: targetSize * 2
  }), React24.createElement("g", {
    className: "tl-clone-button-target",
    onPointerDown: handleClick,
    transform: `translate(${targetSize}, ${targetSize}) rotate(${ROTATIONS[side]})`
  }, React24.createElement("circle", {
    className: "tl-transparent ",
    r: targetSize
  }), React24.createElement("path", {
    className: "tl-clone-button",
    d: `M -${size / 2},-${size / 2} L ${size / 2},0 -${size / 2},${size / 2} Z`,
    strokeLinejoin: "round"
  })));
}
var CloneButton = React24.memo(_CloneButton);
function _CloneButtons({ targetSize, size, bounds }) {
  return React25.createElement(React25.Fragment, null, React25.createElement(CloneButton, {
    targetSize,
    size,
    bounds,
    side: "top"
  }), React25.createElement(CloneButton, {
    targetSize,
    size,
    bounds,
    side: "right"
  }), React25.createElement(CloneButton, {
    targetSize,
    size,
    bounds,
    side: "bottom"
  }), React25.createElement(CloneButton, {
    targetSize,
    size,
    bounds,
    side: "left"
  }), React25.createElement(CloneButton, {
    targetSize,
    size,
    bounds,
    side: "topLeft"
  }), React25.createElement(CloneButton, {
    targetSize,
    size,
    bounds,
    side: "topRight"
  }), React25.createElement(CloneButton, {
    targetSize,
    size,
    bounds,
    side: "bottomLeft"
  }), React25.createElement(CloneButton, {
    targetSize,
    size,
    bounds,
    side: "bottomRight"
  }));
}
var CloneButtons = React25.memo(_CloneButtons);
var cornerBgClassnames = {
  ["top_left_corner"]: "tl-cursor-nwse",
  ["top_right_corner"]: "tl-cursor-nesw",
  ["bottom_right_corner"]: "tl-cursor-nwse",
  ["bottom_left_corner"]: "tl-cursor-nesw"
};
function _CornerHandle({ size, targetSize, isHidden, corner, bounds }) {
  const events = useBoundsHandleEvents(corner);
  const isTop = corner === "top_left_corner" || corner === "top_right_corner";
  const isLeft = corner === "top_left_corner" || corner === "bottom_left_corner";
  return React26.createElement("g", {
    opacity: isHidden ? 0 : 1
  }, React26.createElement("rect", __spreadValues({
    className: "tl-transparent " + (isHidden ? "" : cornerBgClassnames[corner]),
    "aria-label": "corner transparent",
    x: (isLeft ? -1 : bounds.width + 1) - targetSize,
    y: (isTop ? -1 : bounds.height + 1) - targetSize,
    width: targetSize * 2,
    height: targetSize * 2,
    pointerEvents: isHidden ? "none" : "all"
  }, events)), React26.createElement("rect", {
    className: "tl-corner-handle",
    "aria-label": "corner handle",
    x: (isLeft ? -1 : bounds.width + 1) - size / 2,
    y: (isTop ? -1 : bounds.height + 1) - size / 2,
    width: size,
    height: size,
    pointerEvents: "none"
  }));
}
var CornerHandle = React26.memo(_CornerHandle);
var edgeClassnames = {
  ["top_edge"]: "tl-cursor-ns",
  ["right_edge"]: "tl-cursor-ew",
  ["bottom_edge"]: "tl-cursor-ns",
  ["left_edge"]: "tl-cursor-ew"
};
function _EdgeHandle({ size, isHidden, bounds, edge }) {
  const events = useBoundsHandleEvents(edge);
  const isHorizontal = edge === "top_edge" || edge === "bottom_edge";
  const isFarEdge = edge === "right_edge" || edge === "bottom_edge";
  const { height, width } = bounds;
  return React27.createElement("rect", __spreadValues({
    pointerEvents: isHidden ? "none" : "all",
    className: "tl-transparent tl-edge-handle " + (isHidden ? "" : edgeClassnames[edge]),
    "aria-label": `${edge} handle`,
    opacity: isHidden ? 0 : 1,
    x: isHorizontal ? size / 2 : (isFarEdge ? width + 1 : -1) - size / 2,
    y: isHorizontal ? (isFarEdge ? height + 1 : -1) - size / 2 : size / 2,
    width: isHorizontal ? Math.max(0, width + 1 - size) : size,
    height: isHorizontal ? size : Math.max(0, height + 1 - size)
  }, events));
}
var EdgeHandle = React27.memo(_EdgeHandle);
function _LinkHandle({ size, bounds, isHidden }) {
  const leftEvents = useBoundsHandleEvents("left");
  const centerEvents = useBoundsHandleEvents("center");
  const rightEvents = useBoundsHandleEvents("right");
  return React28.createElement("g", {
    cursor: "grab",
    transform: `translate(${bounds.width / 2 - size * 4}, ${bounds.height + size * 2})`,
    "aria-label": "link handle"
  }, React28.createElement("g", {
    className: "tl-transparent",
    pointerEvents: isHidden ? "none" : "all"
  }, React28.createElement("rect", __spreadValues({
    x: 0,
    y: 0,
    width: size * 2,
    height: size * 2
  }, leftEvents)), React28.createElement("rect", __spreadValues({
    x: size * 3,
    y: 0,
    width: size * 2,
    height: size * 2
  }, centerEvents)), React28.createElement("rect", __spreadValues({
    x: size * 6,
    y: 0,
    width: size * 2,
    height: size * 2
  }, rightEvents))), React28.createElement("g", {
    className: "tl-rotate-handle",
    transform: `translate(${size / 2}, ${size / 2})`,
    "aria-label": "link rotate handle"
  }, React28.createElement("path", {
    d: `M 0,${size / 2} L ${size},${size} ${size},0 Z`,
    pointerEvents: "none",
    opacity: isHidden ? 0 : 1
  }), React28.createElement("path", {
    transform: `translate(${size * 3}, 0)`,
    d: `M 0,0 L ${size},0 ${size / 2},${size} Z`,
    pointerEvents: "none",
    opacity: isHidden ? 0 : 1
  }), React28.createElement("path", {
    transform: `translate(${size * 6}, 0)`,
    d: `M ${size},${size / 2} L 0,0 0,${size} Z`,
    pointerEvents: "none",
    opacity: isHidden ? 0 : 1
  })));
}
var LinkHandle = React28.memo(_LinkHandle);
function _RotateHandle({ bounds, targetSize, size, isHidden }) {
  const events = useBoundsHandleEvents("rotate");
  return React29.createElement("g", {
    cursor: "grab",
    opacity: isHidden ? 0 : 1
  }, React29.createElement("circle", __spreadValues({
    className: "tl-transparent",
    "aria-label": "rotate handle transparent",
    cx: bounds.width / 2,
    cy: size * -2,
    r: targetSize,
    pointerEvents: isHidden ? "none" : "all"
  }, events)), React29.createElement("circle", {
    className: "tl-rotate-handle",
    "aria-label": "rotate handle",
    cx: bounds.width / 2,
    cy: size * -2,
    r: size / 2,
    pointerEvents: "none"
  }));
}
var RotateHandle = React29.memo(_RotateHandle);
var _Bounds = function Bounds({
  zoom,
  bounds,
  viewportWidth,
  rotation,
  isHidden,
  isLocked,
  hideCloneHandles,
  hideResizeHandles,
  hideRotateHandle,
  hideBindingHandles
}) {
  const targetSize = (viewportWidth < 768 ? 16 : 8) / zoom;
  const size = 8 / zoom;
  const smallDimension = Math.min(bounds.width, bounds.height) * zoom;
  const showRotateHandle = !hideRotateHandle && !isHidden && !isLocked && smallDimension > 32;
  const showEdgeHandles = !isHidden && !isLocked && smallDimension > 24;
  const showCornerHandles = !isHidden && !isLocked && smallDimension > 20;
  const showCloneHandles = !hideCloneHandles && smallDimension > 24;
  const showResizeHandles = !hideResizeHandles && !isLocked;
  return React30.createElement(Container, {
    bounds,
    rotation
  }, React30.createElement(SVGContainer, null, React30.createElement(CenterHandle, {
    bounds,
    isLocked,
    isHidden
  }), showResizeHandles ? React30.createElement(React30.Fragment, null, React30.createElement(EdgeHandle, {
    targetSize,
    size,
    bounds,
    edge: "top_edge",
    isHidden: !showEdgeHandles
  }), React30.createElement(EdgeHandle, {
    targetSize,
    size,
    bounds,
    edge: "right_edge",
    isHidden: !showEdgeHandles
  }), React30.createElement(EdgeHandle, {
    targetSize,
    size,
    bounds,
    edge: "bottom_edge",
    isHidden: !showEdgeHandles
  }), React30.createElement(EdgeHandle, {
    targetSize,
    size,
    bounds,
    edge: "left_edge",
    isHidden: !showEdgeHandles
  }), React30.createElement(CornerHandle, {
    targetSize,
    size,
    bounds,
    isHidden: isHidden || !showCornerHandles,
    corner: "top_left_corner"
  }), React30.createElement(CornerHandle, {
    targetSize,
    size,
    bounds,
    isHidden: isHidden || !showCornerHandles,
    corner: "top_right_corner"
  }), React30.createElement(CornerHandle, {
    targetSize,
    size,
    bounds,
    isHidden: isHidden || !showCornerHandles,
    corner: "bottom_right_corner"
  }), React30.createElement(CornerHandle, {
    targetSize,
    size,
    bounds,
    isHidden: isHidden || !showCornerHandles,
    corner: "bottom_left_corner"
  })) : null, showRotateHandle && React30.createElement(RotateHandle, {
    targetSize,
    size,
    bounds,
    isHidden: !showEdgeHandles
  }), showCloneHandles && React30.createElement(CloneButtons, {
    bounds,
    targetSize,
    size
  }), !hideBindingHandles && React30.createElement(LinkHandle, {
    targetSize,
    size,
    bounds,
    isHidden: !showEdgeHandles
  })));
};
var Bounds2 = React30.memo(_Bounds);
function _BoundsBg({ bounds, rotation, isHidden }) {
  const events = useBoundsEvents();
  return React31.createElement(Container, {
    bounds,
    rotation
  }, React31.createElement(SVGContainer, null, React31.createElement("rect", __spreadValues({
    className: "tl-bounds-bg",
    "aria-label": "bounds bg",
    width: bounds.width,
    height: bounds.height,
    opacity: isHidden ? 0 : 1
  }, events))));
}
var BoundsBg = React31.memo(_BoundsBg);
function _Handle({ id, point }) {
  const events = useHandleEvents(id);
  return React32.createElement(Container, {
    bounds: utils_default.translateBounds({
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0,
      width: 0,
      height: 0
    }, point)
  }, React32.createElement(SVGContainer, null, React32.createElement("g", __spreadValues({
    className: "tl-handle",
    "aria-label": "handle"
  }, events), React32.createElement("circle", {
    className: "tl-handle-bg",
    pointerEvents: "all"
  }), React32.createElement("circle", {
    className: "tl-counter-scaled tl-handle",
    pointerEvents: "none",
    r: 4
  }))));
}
var Handle = React32.memo(_Handle);
function _Handles({ shape, zoom }) {
  if (shape.handles === void 0) {
    return null;
  }
  let prev = null;
  const handlesToShow = Object.values(shape.handles).reduce((acc, cur) => {
    const point = e.add(cur.point, shape.point);
    if (!prev || e.dist(point, prev) * zoom >= 32) {
      acc.push(cur);
      prev = point;
    }
    return acc;
  }, []);
  if (handlesToShow.length === 1)
    return null;
  return React33.createElement(React33.Fragment, null, handlesToShow.map((handle) => React33.createElement(Handle, {
    key: shape.id + "_" + handle.id,
    id: handle.id,
    point: e.add(handle.point, shape.point)
  })));
}
var Handles = React33.memo(_Handles);
function _RenderedShape(props) {
  const ref = props.utils.getRef(props.shape);
  return React34.createElement(props.utils.Component, __spreadValues({
    ref
  }, props));
}
var RenderedShape = React34.memo(_RenderedShape, (prev, next) => {
  if (prev.isHovered !== next.isHovered || prev.isSelected !== next.isSelected || prev.isEditing !== next.isEditing || prev.isBinding !== next.isBinding || prev.isGhost !== next.isGhost || prev.meta !== next.meta) {
    return false;
  }
  if (next.shape !== prev.shape) {
    return !next.utils.shouldRender(next.shape, prev.shape);
  }
  return true;
});
function _Shape(_a) {
  var _b = _a, {
    shape,
    utils,
    meta
  } = _b, rest = __objRest(_b, [
    "shape",
    "utils",
    "meta"
  ]);
  const { callbacks } = useTLContext();
  const bounds = utils.getBounds(shape);
  const events = useShapeEvents(shape.id);
  return React35.createElement(Container, {
    id: shape.id,
    bounds,
    rotation: shape.rotation,
    "data-shape": shape.type,
    isGhost: rest.isGhost,
    isSelected: rest.isSelected
  }, React35.createElement(RenderedShape, __spreadValues({
    shape,
    utils,
    meta,
    events,
    bounds,
    onShapeChange: callbacks.onShapeChange,
    onShapeBlur: callbacks.onShapeBlur
  }, rest)));
}
var Shape = React35.memo(_Shape);
function _ShapeNode(_a) {
  var _b = _a, {
    shape,
    utils,
    meta,
    children
  } = _b, rest = __objRest(_b, [
    "shape",
    "utils",
    "meta",
    "children"
  ]);
  return React36.createElement(React36.Fragment, null, React36.createElement(Shape, __spreadValues({
    shape,
    utils: utils[shape.type],
    meta
  }, rest)), children && children.map((childNode) => React36.createElement(ShapeNode, __spreadValues({
    key: childNode.shape.id,
    utils
  }, childNode))));
}
var ShapeNode = React36.memo(_ShapeNode);
function _ShapeIndicator({
  isHovered = false,
  isSelected = false,
  isEditing = false,
  shape,
  user,
  meta
}) {
  const { shapeUtils } = useTLContext();
  const utils = shapeUtils[shape.type];
  const bounds = utils.getBounds(shape);
  const rPositioned = usePosition(bounds, shape.rotation);
  return React37.createElement("div", {
    ref: rPositioned,
    draggable: false,
    className: [
      "tl-indicator",
      "tl-absolute",
      isSelected && !user ? "tl-selected" : "tl-hovered",
      isEditing ? "tl-editing" : "",
      shape.isLocked ? "tl-locked" : ""
    ].join(" ")
  }, React37.createElement("svg", {
    width: "100%",
    height: "100%"
  }, React37.createElement("g", {
    className: "tl-centered-g",
    stroke: user == null ? void 0 : user.color
  }, React37.createElement(utils.Indicator, {
    shape,
    meta,
    user,
    bounds,
    isSelected,
    isHovered
  }))));
}
var ShapeIndicator = React37.memo(_ShapeIndicator);
function _Page({
  page,
  pageState,
  assets,
  hideBounds,
  hideHandles,
  hideIndicators,
  hideBindingHandles,
  hideCloneHandles,
  hideRotateHandle,
  hideResizeHandles,
  meta
}) {
  const { bounds: rendererBounds, shapeUtils } = useTLContext();
  const shapeTree = useShapeTree(page, pageState, assets, meta);
  const { bounds, isLinked, isLocked, rotation } = useSelection(page, pageState, shapeUtils);
  const {
    selectedIds,
    hoveredId,
    editingId,
    camera: { zoom }
  } = pageState;
  let _hideIndicators = hideIndicators;
  let _hideCloneHandles = true;
  let _isEditing = false;
  let shapeWithHandles = void 0;
  const selectedShapes = selectedIds.map((id) => page.shapes[id]);
  if (selectedShapes.length === 1) {
    const shape = selectedShapes[0];
    _isEditing = editingId === shape.id;
    if (_isEditing)
      _hideIndicators = true;
    const utils = shapeUtils[shape.type];
    _hideCloneHandles = hideCloneHandles || !utils.showCloneHandles;
    if (shape.handles !== void 0 && !_isEditing) {
      shapeWithHandles = shape;
    }
  }
  return React38.createElement(React38.Fragment, null, bounds && React38.createElement(BoundsBg, {
    bounds,
    rotation,
    isHidden: hideBounds
  }), shapeTree.map((node) => React38.createElement(ShapeNode, __spreadValues({
    key: node.shape.id,
    utils: shapeUtils
  }, node))), !_hideIndicators && selectedShapes.map((shape) => React38.createElement(ShapeIndicator, {
    key: "selected_" + shape.id,
    shape,
    meta,
    isSelected: true,
    isEditing: _isEditing
  })), !_hideIndicators && hoveredId && hoveredId !== editingId && React38.createElement(ShapeIndicator, {
    key: "hovered_" + hoveredId,
    shape: page.shapes[hoveredId],
    meta,
    isHovered: true
  }), bounds && React38.createElement(Bounds2, {
    zoom,
    bounds,
    viewportWidth: rendererBounds.width,
    isLocked,
    rotation,
    isHidden: hideBounds,
    hideRotateHandle,
    hideResizeHandles,
    hideBindingHandles: hideBindingHandles || !isLinked,
    hideCloneHandles: _hideCloneHandles
  }), !hideHandles && shapeWithHandles && React38.createElement(Handles, {
    shape: shapeWithHandles,
    zoom
  }));
}
var Page = React38.memo(_Page);
function _SnapLines({ snapLines }) {
  return React39.createElement(React39.Fragment, null, snapLines.map((snapLine, i) => React39.createElement(SnapLine, {
    key: i,
    snapLine
  })));
}
function _SnapLine({ snapLine }) {
  const bounds = utils_default.getBoundsFromPoints(snapLine);
  return React39.createElement(React39.Fragment, null, React39.createElement("line", {
    className: "tl-snap-line",
    x1: bounds.minX,
    y1: bounds.minY,
    x2: bounds.maxX,
    y2: bounds.maxY
  }), snapLine.map(([x, y], i) => React39.createElement("use", {
    key: i,
    href: "#tl-snap-point",
    x,
    y
  })));
}
var SnapLine = React39.memo(_SnapLine);
var SnapLines = React39.memo(_SnapLines);
function User({ user, Cursor: Cursor2 }) {
  const rCursor = React40.useRef(null);
  React40.useLayoutEffect(() => {
    if (rCursor.current) {
      rCursor.current.style.transform = `translate(${user.point[0]}px, ${user.point[1]}px)`;
    }
  }, [user.point]);
  return React40.createElement("div", {
    ref: rCursor,
    className: `tl-absolute tl-user tl-counter-scaled ${user.session ? "" : "tl-animated"}`
  }, React40.createElement(Cursor2, {
    id: user.id,
    color: user.color,
    metadata: user.metadata
  }));
}
function Users({ userId, users, Cursor: Cursor2 }) {
  return React41.createElement(React41.Fragment, null, Object.values(users).filter((user) => user && user.id !== userId).map((user) => React41.createElement(User, {
    key: user.id,
    user,
    Cursor: Cursor2
  })));
}
function UsersIndicators({
  userId,
  users,
  meta,
  page
}) {
  const { shapeUtils } = useTLContext();
  return React42.createElement(React42.Fragment, null, Object.values(users).filter(Boolean).filter((user) => user.id !== userId && user.selectedIds.length > 0).map((user) => {
    const shapes = user.selectedIds.map((id) => page.shapes[id]).filter(Boolean);
    if (shapes.length === 0)
      return null;
    const bounds = utils_default.getCommonBounds(shapes.map((shape) => shapeUtils[shape.type].getBounds(shape)));
    return React42.createElement(React42.Fragment, {
      key: user.id + "_shapes"
    }, React42.createElement("div", {
      className: "tl-absolute tl-user-indicator-bounds",
      style: {
        backgroundColor: user.color + "0d",
        borderColor: user.color + "78",
        transform: `translate(${bounds.minX}px, ${bounds.minY}px)`,
        width: bounds.width,
        height: bounds.height,
        pointerEvents: "none"
      }
    }), shapes.map((shape) => React42.createElement(ShapeIndicator, {
      key: `${user.id}_${shape.id}_indicator`,
      shape,
      user,
      meta,
      isHovered: true
    })));
  }));
}
var getNearestScrollableContainer = (element) => {
  let parent = element.parentElement;
  while (parent) {
    if (parent === document.body) {
      return document;
    }
    const { overflowY } = window.getComputedStyle(parent);
    const hasScrollableContent = parent.scrollHeight > parent.clientHeight;
    if (hasScrollableContent && (overflowY === "auto" || overflowY === "scroll" || overflowY === "overlay")) {
      return parent;
    }
    parent = parent.parentElement;
  }
  return document;
};
function useResizeObserver(ref, onBoundsChange) {
  const { inputs: inputs2, callbacks } = useTLContext();
  const rIsMounted = React43.useRef(false);
  const updateBounds = React43.useCallback(() => {
    var _a, _b;
    if (rIsMounted.current) {
      const rect = (_a = ref.current) == null ? void 0 : _a.getBoundingClientRect();
      if (rect) {
        const bounds = {
          minX: rect.left,
          maxX: rect.left + rect.width,
          minY: rect.top,
          maxY: rect.top + rect.height,
          width: rect.width,
          height: rect.height
        };
        inputs2.bounds = bounds;
        onBoundsChange(bounds);
        (_b = callbacks.onBoundsChange) == null ? void 0 : _b.call(callbacks, bounds);
      }
    } else {
      rIsMounted.current = true;
    }
  }, [ref, inputs2, callbacks.onBoundsChange]);
  React43.useEffect(() => {
    const scrollingAnchor = ref.current ? getNearestScrollableContainer(ref.current) : document;
    const debouncedupdateBounds = Utils.debounce(updateBounds, 100);
    scrollingAnchor.addEventListener("scroll", debouncedupdateBounds);
    window.addEventListener("resize", debouncedupdateBounds);
    return () => {
      scrollingAnchor.removeEventListener("scroll", debouncedupdateBounds);
      window.removeEventListener("resize", debouncedupdateBounds);
    };
  }, []);
  React43.useEffect(() => {
    const resizeObserver = new ResizeObserver((entries) => {
      if (inputs2.isPinching) {
        return;
      }
      if (entries[0].contentRect) {
        updateBounds();
      }
    });
    if (ref.current) {
      resizeObserver.observe(ref.current);
    }
    return () => {
      resizeObserver.disconnect();
    };
  }, [ref, inputs2]);
  React43.useEffect(() => {
    updateBounds();
  }, [ref]);
}
function _Canvas({
  id,
  page,
  pageState,
  assets,
  snapLines,
  eraseLine,
  grid,
  users,
  userId,
  components = {},
  meta,
  performanceMode,
  showDashedBrush,
  hideHandles,
  hideBounds,
  hideIndicators,
  hideBindingHandles,
  hideCloneHandles,
  hideResizeHandles,
  hideRotateHandle,
  hideGrid,
  onBoundsChange,
  hideCursors
}) {
  var _a;
  const rCanvas = React44.useRef(null);
  const rZoomRef = React44.useRef(pageState.camera.zoom);
  rZoomRef.current = pageState.camera.zoom;
  useZoomEvents(rZoomRef, rCanvas);
  useResizeObserver(rCanvas, onBoundsChange);
  useSafariFocusOutFix();
  usePreventNavigationCss(rCanvas);
  const rContainer = React44.useRef(null);
  const rLayer = React44.useRef(null);
  useCameraCss(rLayer, rContainer, pageState);
  usePerformanceCss(performanceMode, rContainer);
  useKeyEvents();
  const events = useCanvasEvents();
  return React44.createElement("div", {
    id,
    className: "tl-container",
    ref: rContainer
  }, React44.createElement("div", __spreadValues({
    id: "canvas",
    className: "tl-absolute tl-canvas",
    ref: rCanvas
  }, events), !hideGrid && grid && React44.createElement(Grid, {
    grid,
    camera: pageState.camera
  }), React44.createElement("div", {
    ref: rLayer,
    className: "tl-absolute tl-layer",
    "data-testid": "layer"
  }, React44.createElement(Page, {
    page,
    pageState,
    assets,
    hideBounds,
    hideIndicators,
    hideHandles,
    hideBindingHandles,
    hideCloneHandles,
    hideResizeHandles,
    hideRotateHandle,
    meta
  }), users && userId && React44.createElement(UsersIndicators, {
    userId,
    users,
    page,
    meta
  }), pageState.brush && React44.createElement(Brush, {
    brush: pageState.brush,
    dashed: showDashedBrush,
    zoom: pageState.camera.zoom
  }), users && !hideCursors && React44.createElement(Users, {
    userId,
    users,
    Cursor: (_a = components == null ? void 0 : components.Cursor) != null ? _a : Cursor
  })), React44.createElement(Overlay, {
    camera: pageState.camera
  }, eraseLine && React44.createElement(EraseLine, {
    points: eraseLine,
    zoom: pageState.camera.zoom
  }), snapLines && React44.createElement(SnapLines, {
    snapLines
  }))));
}
var Canvas = React44.memo(_Canvas);
var DOUBLE_CLICK_DURATION = 250;
var Inputs = class {
  constructor() {
    __publicField(this, "pointer");
    __publicField(this, "keyboard");
    __publicField(this, "keys", {});
    __publicField(this, "isPinching", false);
    __publicField(this, "bounds", {
      minX: 0,
      maxX: 640,
      minY: 0,
      maxY: 480,
      width: 640,
      height: 480
    });
    __publicField(this, "pointerUpTime", 0);
    __publicField(this, "activePointer");
    __publicField(this, "panStart", (e2) => {
      var _a, _b;
      const { shiftKey, ctrlKey, metaKey, altKey } = e2;
      const info = {
        target: "wheel",
        pointerId: ((_a = this.pointer) == null ? void 0 : _a.pointerId) || 0,
        origin: ((_b = this.pointer) == null ? void 0 : _b.origin) || [0, 0],
        delta: [0, 0],
        pressure: 0.5,
        point: Inputs.getPoint(e2, this.bounds),
        shiftKey,
        ctrlKey,
        metaKey,
        altKey,
        spaceKey: this.keys[" "]
      };
      this.pointer = info;
      return info;
    });
    __publicField(this, "pan", (delta, e2) => {
      if (!this.pointer || this.pointer.target !== "wheel") {
        return this.panStart(e2);
      }
      const { shiftKey, ctrlKey, metaKey, altKey } = e2;
      const prev = this.pointer;
      const point = Inputs.getPoint(e2, this.bounds);
      const info = __spreadProps(__spreadValues({}, prev), {
        target: "wheel",
        delta,
        point,
        shiftKey,
        ctrlKey,
        metaKey,
        altKey,
        spaceKey: this.keys[" "]
      });
      this.pointer = info;
      return info;
    });
    __publicField(this, "keydown", (e2) => {
      var _a, _b;
      const { shiftKey, ctrlKey, metaKey, altKey } = e2;
      this.keys[e2.key] = true;
      return {
        point: ((_a = this.pointer) == null ? void 0 : _a.point) || [0, 0],
        origin: ((_b = this.pointer) == null ? void 0 : _b.origin) || [0, 0],
        key: e2.key,
        keys: Object.keys(this.keys),
        shiftKey,
        ctrlKey,
        metaKey: Utils.isDarwin() ? metaKey : ctrlKey,
        altKey
      };
    });
    __publicField(this, "keyup", (e2) => {
      var _a, _b;
      const { shiftKey, ctrlKey, metaKey, altKey } = e2;
      delete this.keys[e2.key];
      return {
        point: ((_a = this.pointer) == null ? void 0 : _a.point) || [0, 0],
        origin: ((_b = this.pointer) == null ? void 0 : _b.origin) || [0, 0],
        key: e2.key,
        keys: Object.keys(this.keys),
        shiftKey,
        ctrlKey,
        metaKey: Utils.isDarwin() ? metaKey : ctrlKey,
        altKey
      };
    });
  }
  pointerIsValid(e2) {
    if ("pointerId" in e2) {
      if (this.activePointer && this.activePointer !== e2.pointerId) {
        return false;
      }
    }
    if ("touches" in e2) {
      const touch = e2.changedTouches[0];
      if (this.activePointer && this.activePointer !== touch.identifier) {
        return false;
      }
    }
    return true;
  }
  touchStart(e2, target) {
    const { shiftKey, ctrlKey, metaKey, altKey } = e2;
    const touch = e2.changedTouches[0];
    this.activePointer = touch.identifier;
    const info = {
      target,
      pointerId: touch.identifier,
      origin: Inputs.getPoint(touch, this.bounds),
      delta: [0, 0],
      point: Inputs.getPoint(touch, this.bounds),
      pressure: Inputs.getPressure(touch),
      shiftKey,
      ctrlKey,
      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,
      altKey,
      spaceKey: this.keys[" "]
    };
    this.pointer = info;
    return info;
  }
  touchEnd(e2, target) {
    const { shiftKey, ctrlKey, metaKey, altKey } = e2;
    const touch = e2.changedTouches[0];
    const info = {
      target,
      pointerId: touch.identifier,
      origin: Inputs.getPoint(touch, this.bounds),
      delta: [0, 0],
      point: Inputs.getPoint(touch, this.bounds),
      pressure: Inputs.getPressure(touch),
      shiftKey,
      ctrlKey,
      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,
      altKey,
      spaceKey: this.keys[" "]
    };
    this.pointer = info;
    this.activePointer = void 0;
    return info;
  }
  touchMove(e2, target) {
    const { shiftKey, ctrlKey, metaKey, altKey } = e2;
    const touch = e2.changedTouches[0];
    const prev = this.pointer;
    const point = Inputs.getPoint(touch, this.bounds);
    const delta = (prev == null ? void 0 : prev.point) ? e.sub(point, prev.point) : [0, 0];
    const info = __spreadProps(__spreadValues({
      origin: point
    }, prev), {
      target,
      pointerId: touch.identifier,
      point,
      delta,
      pressure: Inputs.getPressure(touch),
      shiftKey,
      ctrlKey,
      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,
      altKey,
      spaceKey: this.keys[" "]
    });
    this.pointer = info;
    return info;
  }
  pointerDown(e2, target) {
    const { shiftKey, ctrlKey, metaKey, altKey } = e2;
    const point = Inputs.getPoint(e2, this.bounds);
    this.activePointer = e2.pointerId;
    const info = {
      target,
      pointerId: e2.pointerId,
      origin: point,
      point,
      delta: [0, 0],
      pressure: Inputs.getPressure(e2),
      shiftKey,
      ctrlKey,
      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,
      altKey,
      spaceKey: this.keys[" "]
    };
    this.pointer = info;
    return info;
  }
  pointerEnter(e2, target) {
    const { shiftKey, ctrlKey, metaKey, altKey } = e2;
    const point = Inputs.getPoint(e2, this.bounds);
    const info = {
      target,
      pointerId: e2.pointerId,
      origin: point,
      delta: [0, 0],
      point,
      pressure: Inputs.getPressure(e2),
      shiftKey,
      ctrlKey,
      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,
      altKey,
      spaceKey: this.keys[" "]
    };
    this.pointer = info;
    return info;
  }
  pointerMove(e2, target) {
    const { shiftKey, ctrlKey, metaKey, altKey } = e2;
    const prev = this.pointer;
    const point = Inputs.getPoint(e2, this.bounds);
    const delta = (prev == null ? void 0 : prev.point) ? e.sub(point, prev.point) : [0, 0];
    const info = __spreadProps(__spreadValues({
      origin: point
    }, prev), {
      target,
      pointerId: e2.pointerId,
      point,
      delta,
      pressure: Inputs.getPressure(e2),
      shiftKey,
      ctrlKey,
      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,
      altKey,
      spaceKey: this.keys[" "]
    });
    this.pointer = info;
    return info;
  }
  pointerUp(e2, target) {
    const { shiftKey, ctrlKey, metaKey, altKey } = e2;
    const prev = this.pointer;
    const point = Inputs.getPoint(e2, this.bounds);
    const delta = (prev == null ? void 0 : prev.point) ? e.sub(point, prev.point) : [0, 0];
    this.activePointer = void 0;
    const info = __spreadProps(__spreadValues({
      origin: point
    }, prev), {
      target,
      pointerId: e2.pointerId,
      point,
      delta,
      pressure: Inputs.getPressure(e2),
      shiftKey,
      ctrlKey,
      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,
      altKey,
      spaceKey: this.keys[" "]
    });
    this.pointer = info;
    this.pointerUpTime = performance.now();
    return info;
  }
  isDoubleClick() {
    if (!this.pointer)
      return false;
    const { origin, point } = this.pointer;
    const isDoubleClick = performance.now() - this.pointerUpTime < DOUBLE_CLICK_DURATION && e.dist(origin, point) < 4;
    if (isDoubleClick)
      this.activePointer = void 0;
    return isDoubleClick;
  }
  clear() {
    this.pointer = void 0;
  }
  resetDoubleClick() {
    this.pointerUpTime = 0;
  }
  pinch(point, origin) {
    const { shiftKey, ctrlKey, metaKey, altKey } = this.keys;
    const delta = e.sub(origin, point);
    const info = {
      pointerId: 0,
      target: "pinch",
      origin,
      delta,
      point: e.sub(e.toFixed(point), [this.bounds.minX, this.bounds.minY]),
      pressure: 0.5,
      shiftKey,
      ctrlKey,
      metaKey: Utils.isDarwin() ? metaKey : ctrlKey,
      altKey,
      spaceKey: this.keys[" "]
    };
    this.pointer = info;
    return info;
  }
  reset() {
    this.pointerUpTime = 0;
    this.pointer = void 0;
    this.keyboard = void 0;
    this.activePointer = void 0;
    this.keys = {};
  }
  static getPoint(e2, bounds) {
    return [+e2.clientX.toFixed(2) - bounds.minX, +e2.clientY.toFixed(2) - bounds.minY];
  }
  static getPressure(e2) {
    return "pressure" in e2 ? +e2.pressure.toFixed(2) || 0.5 : 0.5;
  }
  static commandKey() {
    return Utils.isDarwin() ? "\u2318" : "Ctrl";
  }
};
var inputs = new Inputs();
var EMPTY_OBJECT = Object.freeze({});
function _Renderer(_a) {
  var _b = _a, {
    id = "tl",
    shapeUtils,
    page,
    pageState,
    assets = EMPTY_OBJECT,
    users,
    userId,
    theme,
    meta,
    snapLines,
    eraseLine,
    grid,
    containerRef,
    performanceMode,
    components,
    hideHandles = false,
    hideIndicators = false,
    hideCloneHandles = false,
    hideBindingHandles = false,
    hideResizeHandles = false,
    hideRotateHandles = false,
    hideBounds = false,
    hideGrid = true,
    showDashedBrush = false,
    hideCursors
  } = _b, rest = __objRest(_b, [
    "id",
    "shapeUtils",
    "page",
    "pageState",
    "assets",
    "users",
    "userId",
    "theme",
    "meta",
    "snapLines",
    "eraseLine",
    "grid",
    "containerRef",
    "performanceMode",
    "components",
    "hideHandles",
    "hideIndicators",
    "hideCloneHandles",
    "hideBindingHandles",
    "hideResizeHandles",
    "hideRotateHandles",
    "hideBounds",
    "hideGrid",
    "showDashedBrush",
    "hideCursors"
  ]);
  useTLTheme(theme, "#" + id);
  const rSelectionBounds = React45.useRef(null);
  const rPageState = React45.useRef(pageState);
  React45.useEffect(() => {
    rPageState.current = pageState;
  }, [pageState]);
  const [context, setContext] = React45.useState(() => ({
    callbacks: rest,
    shapeUtils,
    rSelectionBounds,
    rPageState,
    bounds: {
      minX: 0,
      minY: 0,
      maxX: Infinity,
      maxY: Infinity,
      width: Infinity,
      height: Infinity
    },
    inputs: new Inputs()
  }));
  const onBoundsChange = React45.useCallback((bounds) => {
    setContext((context2) => __spreadProps(__spreadValues({}, context2), {
      bounds
    }));
  }, []);
  return React45.createElement(TLContext.Provider, {
    value: context
  }, React45.createElement(Canvas, {
    id,
    page,
    pageState,
    assets,
    snapLines,
    eraseLine,
    grid,
    users,
    userId,
    externalContainerRef: containerRef,
    hideBounds,
    hideIndicators,
    hideHandles,
    hideCloneHandles,
    hideBindingHandles,
    hideRotateHandle: hideRotateHandles,
    hideResizeHandles,
    hideGrid,
    showDashedBrush,
    onBoundsChange,
    performanceMode,
    components,
    meta,
    hideCursors
  }));
}
var Renderer = React45.memo(_Renderer);
var HTMLContainer = React46.memo(React46.forwardRef(function HTMLContainer2(_a, ref) {
  var _b = _a, { children, className = "" } = _b, rest = __objRest(_b, ["children", "className"]);
  return React46.createElement("div", __spreadValues({
    ref,
    className: `tl-positioned-div ${className}`,
    draggable: false
  }, rest), React46.createElement("div", {
    className: "tl-inner-div"
  }, children));
}));
var TLShapeUtil = class {
  constructor() {
    __publicField(this, "refMap", /* @__PURE__ */ new Map());
    __publicField(this, "boundsCache", /* @__PURE__ */ new WeakMap());
    __publicField(this, "showCloneHandles", false);
    __publicField(this, "hideBounds", false);
    __publicField(this, "isStateful", false);
    __publicField(this, "shouldRender", (prev, next) => true);
    __publicField(this, "getRef", (shape) => {
      if (!this.refMap.has(shape.id)) {
        this.refMap.set(shape.id, React47.createRef());
      }
      return this.refMap.get(shape.id);
    });
    __publicField(this, "hitTestBounds", (shape, bounds) => {
      const shapeBounds = this.getBounds(shape);
      const corners = utils_default.getRotatedCorners(shapeBounds, shape.rotation);
      return corners.every((point) => utils_default.pointInBounds(point, bounds)) || ee(corners, bounds).length > 0;
    });
    __publicField(this, "getRotatedBounds", (shape) => {
      return utils_default.getBoundsFromPoints(utils_default.getRotatedCorners(this.getBounds(shape), shape.rotation));
    });
  }
};
__publicField(TLShapeUtil, "Component", (component) => {
  return React47.forwardRef(component);
});
__publicField(TLShapeUtil, "Indicator", (component) => component);
export {
  Cursor,
  HTMLContainer,
  Inputs,
  Renderer,
  SVGContainer,
  SnapPoints,
  TLBoundsCorner,
  TLBoundsEdge,
  TLPerformanceMode,
  TLShapeUtil,
  Utils,
  inputs
};
/**
 * String.prototype.replaceAll() polyfill
 * https://gomakethings.com/how-to-replace-a-section-of-a-string-with-another-one-with-vanilla-js/
 * @author Chris Ferdinandi
 * @license MIT
 */
//# sourceMappingURL=@tldraw_core.js.map
