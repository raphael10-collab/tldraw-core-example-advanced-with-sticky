{
  "version": 3,
  "sources": ["../../@tldraw/intersect/src/index.ts"],
  "sourcesContent": ["import { Vec } from '@tldraw/vec'\n\nexport type TLIntersection = {\n  didIntersect: boolean\n  message: string\n  points: number[][]\n}\n\nexport interface TLBounds {\n  minX: number\n  minY: number\n  maxX: number\n  maxY: number\n  width: number\n  height: number\n  rotation?: number\n}\n\n/**\n * Get an intersection.\n * @param message\n * @param points\n * @internal\n */\nfunction createIntersection(message: string, ...points: number[][]): TLIntersection {\n  const didIntersect = points.length > 0\n  return { didIntersect, message, points }\n}\n\n/**\n *\n * @param point\n * @param size\n * @param rotation\n * @internal\n */\nfunction getRectangleSides(point: number[], size: number[], rotation = 0): [string, number[][]][] {\n  const center = [point[0] + size[0] / 2, point[1] + size[1] / 2]\n  const tl = Vec.rotWith(point, center, rotation)\n  const tr = Vec.rotWith(Vec.add(point, [size[0], 0]), center, rotation)\n  const br = Vec.rotWith(Vec.add(point, size), center, rotation)\n  const bl = Vec.rotWith(Vec.add(point, [0, size[1]]), center, rotation)\n\n  return [\n    ['top', [tl, tr]],\n    ['right', [tr, br]],\n    ['bottom', [br, bl]],\n    ['left', [bl, tl]],\n  ]\n}\n\n/**\n * Get whether angle c lies between angles a and b.\n * @param a\n * @param b\n * @param c\n * @internal\n */\nfunction isAngleBetween(a: number, b: number, c: number): boolean {\n  if (c === a || c === b) return true\n  const PI2 = Math.PI * 2\n  const AB = (b - a + PI2) % PI2\n  const AC = (c - a + PI2) % PI2\n  return AB <= Math.PI !== AC > AB\n}\n\n/* -------------------------------------------------- */\n/*                        Line                        */\n/* -------------------------------------------------- */\n\nexport function intersectLineLine(AB: number[][], PQ: number[][]): number[] | undefined {\n  const slopeAB = Vec.slope(AB[0], AB[1])\n  const slopePQ = Vec.slope(PQ[0], PQ[1])\n\n  if (slopeAB === slopePQ) return undefined\n\n  if (Number.isNaN(slopeAB) && !Number.isNaN(slopePQ)) {\n    return [AB[0][0], (AB[0][0] - PQ[0][0]) * slopePQ + PQ[0][1]]\n  }\n\n  if (Number.isNaN(slopePQ) && !Number.isNaN(slopeAB)) {\n    return [PQ[0][0], (PQ[0][0] - AB[0][0]) * slopeAB + AB[0][1]]\n  }\n\n  const x = (slopeAB * AB[0][0] - slopePQ * PQ[0][0] + PQ[0][1] - AB[0][1]) / (slopeAB - slopePQ)\n  const y = slopePQ * (x - PQ[0][0]) + PQ[0][1]\n\n  return [x, y]\n}\n\n/* -------------------------------------------------- */\n/*                         Ray                        */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersection between a ray and a ray.\n * @param p0 The first ray's point\n * @param n0 The first ray's direction vector.\n * @param p1 The second ray's point.\n * @param n1 The second ray's direction vector.\n */\nexport function intersectRayRay(\n  p0: number[],\n  n0: number[],\n  p1: number[],\n  n1: number[]\n): TLIntersection {\n  const dx = p1[0] - p0[0]\n  const dy = p1[1] - p0[1]\n  const det = n1[0] * n0[1] - n1[1] * n0[0]\n  const u = (dy * n1[0] - dx * n1[1]) / det\n  const v = (dy * n0[0] - dx * n0[1]) / det\n  if (u < 0 || v < 0) return createIntersection('miss')\n\n  const m0 = n0[1] / n0[0]\n  const m1 = n1[1] / n1[0]\n  const b0 = p0[1] - m0 * p0[0]\n  const b1 = p1[1] - m1 * p1[0]\n  const x = (b1 - b0) / (m0 - m1)\n  const y = m0 * x + b0\n\n  return Number.isFinite(x)\n    ? createIntersection('intersection', [x, y])\n    : createIntersection('parallel')\n}\n\n/**\n * Find the intersections between a ray and a line segment.\n * @param origin\n * @param direction\n * @param a1\n * @param a2\n */\nexport function intersectRayLineSegment(\n  origin: number[],\n  direction: number[],\n  a1: number[],\n  a2: number[]\n): TLIntersection {\n  const [x, y] = origin\n  const [dx, dy] = direction\n  const [x1, y1] = a1\n  const [x2, y2] = a2\n\n  if (dy / dx !== (y2 - y1) / (x2 - x1)) {\n    const d = dx * (y2 - y1) - dy * (x2 - x1)\n    if (d !== 0) {\n      const r = ((y - y1) * (x2 - x1) - (x - x1) * (y2 - y1)) / d\n      const s = ((y - y1) * dx - (x - x1) * dy) / d\n      if (r >= 0 && s >= 0 && s <= 1) {\n        return createIntersection('intersection', [x + r * dx, y + r * dy])\n      }\n    }\n  }\n  return createIntersection('no intersection')\n}\n\n/**\n * Find the intersections between a ray and a rectangle.\n * @param origin\n * @param direction\n * @param point\n * @param size\n * @param rotation\n */\nexport function intersectRayRectangle(\n  origin: number[],\n  direction: number[],\n  point: number[],\n  size: number[],\n  rotation = 0\n): TLIntersection[] {\n  return intersectRectangleRay(point, size, rotation, origin, direction)\n}\n\n/**\n * Find the intersections between a ray and an ellipse.\n * @param origin\n * @param direction\n * @param center\n * @param rx\n * @param ry\n * @param rotation\n */\nexport function intersectRayEllipse(\n  origin: number[],\n  direction: number[],\n  center: number[],\n  rx: number,\n  ry: number,\n  rotation: number\n): TLIntersection {\n  const a1 = origin\n  const a2 = Vec.mul(direction, 999999999)\n  return intersectLineSegmentEllipse(a1, a2, center, rx, ry, rotation)\n}\n\n/**\n * Find the intersections between a ray and a bounding box.\n * @param origin\n * @param direction\n * @param bounds\n * @param rotation\n */\nexport function intersectRayBounds(\n  origin: number[],\n  direction: number[],\n  bounds: TLBounds,\n  rotation = 0\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectRayRectangle(origin, direction, [minX, minY], [width, height], rotation)\n}\n\n/* -------------------------------------------------- */\n/*                    Line Segment                    */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersection between a line segment and a ray.\n * @param a1\n * @param a2\n * @param origin\n * @param direction\n */\nexport function intersectLineSegmentRay(\n  a1: number[],\n  a2: number[],\n  origin: number[],\n  direction: number[]\n): TLIntersection {\n  return intersectRayLineSegment(origin, direction, a1, a2)\n}\n\n/**\n * Find the intersection between a line segment and a line segment.\n * @param a1\n * @param a2\n * @param b1\n * @param b2\n */\nexport function intersectLineSegmentLineSegment(\n  a1: number[],\n  a2: number[],\n  b1: number[],\n  b2: number[]\n): TLIntersection {\n  const AB = Vec.sub(a1, b1)\n  const BV = Vec.sub(b2, b1)\n  const AV = Vec.sub(a2, a1)\n\n  const ua_t = BV[0] * AB[1] - BV[1] * AB[0]\n  const ub_t = AV[0] * AB[1] - AV[1] * AB[0]\n  const u_b = BV[1] * AV[0] - BV[0] * AV[1]\n\n  if (ua_t === 0 || ub_t === 0) {\n    return createIntersection('coincident')\n  }\n\n  if (u_b === 0) {\n    return createIntersection('parallel')\n  }\n\n  if (u_b !== 0) {\n    const ua = ua_t / u_b\n    const ub = ub_t / u_b\n    if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\n      return createIntersection('intersection', Vec.add(a1, Vec.mul(AV, ua)))\n    }\n  }\n\n  return createIntersection('no intersection')\n}\n\n/**\n * Find the intersections between a line segment and a rectangle.\n * @param a1\n * @param a2\n * @param point\n * @param size\n */\nexport function intersectLineSegmentRectangle(\n  a1: number[],\n  a2: number[],\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  return intersectRectangleLineSegment(point, size, a1, a2)\n}\n\n/**\n * Find the intersections between a line segment and an arc.\n * @param a1\n * @param a2\n * @param center\n * @param radius\n * @param start\n * @param end\n */\nexport function intersectLineSegmentArc(\n  a1: number[],\n  a2: number[],\n  center: number[],\n  radius: number,\n  start: number[],\n  end: number[]\n): TLIntersection {\n  const sa = Vec.angle(center, start)\n  const ea = Vec.angle(center, end)\n  const ellipseTest = intersectEllipseLineSegment(center, radius, radius, 0, a1, a2)\n\n  if (!ellipseTest.didIntersect) return createIntersection('no intersection')\n\n  const points = ellipseTest.points.filter((point) =>\n    isAngleBetween(sa, ea, Vec.angle(center, point))\n  )\n\n  if (points.length === 0) {\n    return createIntersection('no intersection')\n  }\n\n  return createIntersection('intersection', ...points)\n}\n\n/**\n * Find the intersections between a line segment and a circle.\n * @param a1\n * @param a2\n * @param c\n * @param r\n */\nexport function intersectLineSegmentCircle(\n  a1: number[],\n  a2: number[],\n  c: number[],\n  r: number\n): TLIntersection {\n  const a = (a2[0] - a1[0]) * (a2[0] - a1[0]) + (a2[1] - a1[1]) * (a2[1] - a1[1])\n  const b = 2 * ((a2[0] - a1[0]) * (a1[0] - c[0]) + (a2[1] - a1[1]) * (a1[1] - c[1]))\n  const cc =\n    c[0] * c[0] +\n    c[1] * c[1] +\n    a1[0] * a1[0] +\n    a1[1] * a1[1] -\n    2 * (c[0] * a1[0] + c[1] * a1[1]) -\n    r * r\n\n  const deter = b * b - 4 * a * cc\n\n  if (deter < 0) {\n    return createIntersection('outside')\n  }\n\n  if (deter === 0) {\n    return createIntersection('tangent')\n  }\n\n  const e = Math.sqrt(deter)\n  const u1 = (-b + e) / (2 * a)\n  const u2 = (-b - e) / (2 * a)\n  if ((u1 < 0 || u1 > 1) && (u2 < 0 || u2 > 1)) {\n    if ((u1 < 0 && u2 < 0) || (u1 > 1 && u2 > 1)) {\n      return createIntersection('outside')\n    } else {\n      return createIntersection('inside')\n    }\n  }\n\n  const results: number[][] = []\n  if (0 <= u1 && u1 <= 1) results.push(Vec.lrp(a1, a2, u1))\n  if (0 <= u2 && u2 <= 1) results.push(Vec.lrp(a1, a2, u2))\n\n  return createIntersection('intersection', ...results)\n}\n\n/**\n * Find the intersections between a line segment and an ellipse.\n * @param a1\n * @param a2\n * @param center\n * @param rx\n * @param ry\n * @param rotation\n */\nexport function intersectLineSegmentEllipse(\n  a1: number[],\n  a2: number[],\n  center: number[],\n  rx: number,\n  ry: number,\n  rotation = 0\n): TLIntersection {\n  // If the ellipse or line segment are empty, return no tValues.\n  if (rx === 0 || ry === 0 || Vec.isEqual(a1, a2)) {\n    return createIntersection('no intersection')\n  }\n\n  // Get the semimajor and semiminor axes.\n  rx = rx < 0 ? rx : -rx\n  ry = ry < 0 ? ry : -ry\n\n  // Rotate points and translate so the ellipse is centered at the origin.\n  a1 = Vec.sub(Vec.rotWith(a1, center, -rotation), center)\n  a2 = Vec.sub(Vec.rotWith(a2, center, -rotation), center)\n\n  // Calculate the quadratic parameters.\n  const diff = Vec.sub(a2, a1)\n\n  const A = (diff[0] * diff[0]) / rx / rx + (diff[1] * diff[1]) / ry / ry\n  const B = (2 * a1[0] * diff[0]) / rx / rx + (2 * a1[1] * diff[1]) / ry / ry\n  const C = (a1[0] * a1[0]) / rx / rx + (a1[1] * a1[1]) / ry / ry - 1\n\n  // Make a list of t values (normalized points on the line where intersections occur).\n  const tValues: number[] = []\n\n  // Calculate the discriminant.\n  const discriminant = B * B - 4 * A * C\n\n  if (discriminant === 0) {\n    // One real solution.\n    tValues.push(-B / 2 / A)\n  } else if (discriminant > 0) {\n    const root = Math.sqrt(discriminant)\n    // Two real solutions.\n    tValues.push((-B + root) / 2 / A)\n    tValues.push((-B - root) / 2 / A)\n  }\n\n  // Filter to only points that are on the segment.\n  // Solve for points, then counter-rotate points.\n  const points = tValues\n    .filter((t) => t >= 0 && t <= 1)\n    .map((t) => Vec.add(center, Vec.add(a1, Vec.mul(Vec.sub(a2, a1), t))))\n    .map((p) => Vec.rotWith(p, center, rotation))\n\n  return createIntersection('intersection', ...points)\n}\n\n/**\n * Find the intersections between a line segment and a bounding box.\n * @param a1\n * @param a2\n * @param bounds\n */\nexport function intersectLineSegmentBounds(\n  a1: number[],\n  a2: number[],\n  bounds: TLBounds\n): TLIntersection[] {\n  return intersectBoundsLineSegment(bounds, a1, a2)\n}\n\n/**\n * Find the intersections between a line segment and a polyline.\n * @param a1\n * @param a2\n * @param points\n */\nexport function intersectLineSegmentPolyline(\n  a1: number[],\n  a2: number[],\n  points: number[][]\n): TLIntersection {\n  const pts: number[][] = []\n\n  for (let i = 1; i < points.length; i++) {\n    const int = intersectLineSegmentLineSegment(a1, a2, points[i - 1], points[i])\n\n    if (int) {\n      pts.push(...int.points)\n    }\n  }\n\n  if (pts.length === 0) {\n    return createIntersection('no intersection')\n  }\n\n  return createIntersection('intersection', ...points)\n}\n/**\n * Find the intersections between a line segment and a closed polygon.\n * @param a1\n * @param a2\n * @param points\n */\nexport function intersectLineSegmentPolygon(\n  a1: number[],\n  a2: number[],\n  points: number[][]\n): TLIntersection {\n  const pts: number[][] = []\n\n  for (let i = 1; i < points.length + 1; i++) {\n    const int = intersectLineSegmentLineSegment(a1, a2, points[i - 1], points[i % points.length])\n\n    if (int) {\n      pts.push(...int.points)\n    }\n  }\n\n  if (pts.length === 0) {\n    return createIntersection('no intersection')\n  }\n\n  return createIntersection('intersection', ...points)\n}\n\n/* -------------------------------------------------- */\n/*                      Rectangle                     */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersections between a rectangle and a ray.\n * @param point\n * @param size\n * @param rotation\n * @param origin\n * @param direction\n */\nexport function intersectRectangleRay(\n  point: number[],\n  size: number[],\n  rotation: number,\n  origin: number[],\n  direction: number[]\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size, rotation).reduce<TLIntersection[]>(\n    (acc, [message, [a1, a2]]) => {\n      const intersection = intersectRayLineSegment(origin, direction, a1, a2)\n\n      if (intersection) {\n        acc.push(createIntersection(message, ...intersection.points))\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/**\n * Find the intersections between a rectangle and a line segment.\n * @param point\n * @param size\n * @param a1\n * @param a2\n */\nexport function intersectRectangleLineSegment(\n  point: number[],\n  size: number[],\n  a1: number[],\n  a2: number[]\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size).reduce<TLIntersection[]>(\n    (acc, [message, [b1, b2]]) => {\n      const intersection = intersectLineSegmentLineSegment(a1, a2, b1, b2)\n\n      if (intersection) {\n        acc.push(createIntersection(message, ...intersection.points))\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/**\n * Find the intersections between a rectangle and a rectangle.\n * @param point1\n * @param size1\n * @param point2\n * @param size2\n */\nexport function intersectRectangleRectangle(\n  point1: number[],\n  size1: number[],\n  point2: number[],\n  size2: number[]\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point1, size1).reduce<TLIntersection[]>(\n    (acc, [message, [a1, a2]]) => {\n      const intersections = intersectRectangleLineSegment(point2, size2, a1, a2)\n\n      acc.push(\n        ...intersections.map((int) =>\n          createIntersection(`${message} ${int.message}`, ...int.points)\n        )\n      )\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/**\n * Find the intersections between a rectangle and an arc.\n * @param point\n * @param size\n * @param center\n * @param radius\n * @param start\n * @param end\n */\nexport function intersectRectangleArc(\n  point: number[],\n  size: number[],\n  center: number[],\n  radius: number,\n  start: number[],\n  end: number[]\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size).reduce<TLIntersection[]>(\n    (acc, [message, [a1, a2]]) => {\n      const intersection = intersectArcLineSegment(center, radius, start, end, a1, a2)\n\n      if (intersection) {\n        acc.push({ ...intersection, message })\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/**\n * Find the intersections between a rectangle and a circle.\n * @param point\n * @param size\n * @param c\n * @param r\n */\nexport function intersectRectangleCircle(\n  point: number[],\n  size: number[],\n  c: number[],\n  r: number\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size).reduce<TLIntersection[]>(\n    (acc, [message, [a1, a2]]) => {\n      const intersection = intersectLineSegmentCircle(a1, a2, c, r)\n\n      if (intersection) {\n        acc.push({ ...intersection, message })\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/**\n * Find the intersections between a rectangle and an ellipse.\n * @param point\n * @param size\n * @param c\n * @param rx\n * @param ry\n * @param rotation\n */\nexport function intersectRectangleEllipse(\n  point: number[],\n  size: number[],\n  c: number[],\n  rx: number,\n  ry: number,\n  rotation = 0\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size).reduce<TLIntersection[]>(\n    (acc, [message, [a1, a2]]) => {\n      const intersection = intersectLineSegmentEllipse(a1, a2, c, rx, ry, rotation)\n\n      if (intersection) {\n        acc.push({ ...intersection, message })\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/**\n * Find the intersections between a rectangle and a bounding box.\n * @param point\n * @param size\n * @param bounds\n */\nexport function intersectRectangleBounds(\n  point: number[],\n  size: number[],\n  bounds: TLBounds\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectRectangleRectangle(point, size, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a rectangle and a polyline.\n * @param point\n * @param size\n * @param points\n */\nexport function intersectRectanglePolyline(\n  point: number[],\n  size: number[],\n  points: number[][]\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size).reduce<TLIntersection[]>(\n    (acc, [message, [a1, a2]]) => {\n      const intersection = intersectLineSegmentPolyline(a1, a2, points)\n\n      if (intersection.didIntersect) {\n        acc.push(createIntersection(message, ...intersection.points))\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n/**\n * Find the intersections between a rectangle and a polygon.\n * @param point\n * @param size\n * @param points\n */\nexport function intersectRectanglePolygon(\n  point: number[],\n  size: number[],\n  points: number[][]\n): TLIntersection[] {\n  const sideIntersections = getRectangleSides(point, size).reduce<TLIntersection[]>(\n    (acc, [message, [a1, a2]]) => {\n      const intersection = intersectLineSegmentPolygon(a1, a2, points)\n\n      if (intersection.didIntersect) {\n        acc.push(createIntersection(message, ...intersection.points))\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\n/* -------------------------------------------------- */\n/*                         Arc                        */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersections between a arc and a line segment.\n * @param center\n * @param radius\n * @param start\n * @param end\n * @param a1\n * @param a2\n */\nexport function intersectArcLineSegment(\n  center: number[],\n  radius: number,\n  start: number[],\n  end: number[],\n  a1: number[],\n  a2: number[]\n): TLIntersection {\n  return intersectLineSegmentArc(a1, a2, center, radius, start, end)\n}\n\n/**\n * Find the intersections between a arc and a rectangle.\n * @param center\n * @param radius\n * @param start\n * @param end\n * @param point\n * @param size\n */\nexport function intersectArcRectangle(\n  center: number[],\n  radius: number,\n  start: number[],\n  end: number[],\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  return intersectRectangleArc(point, size, center, radius, start, end)\n}\n\n/**\n * Find the intersections between a arc and a bounding box.\n * @param center\n * @param radius\n * @param start\n * @param end\n * @param bounds\n */\nexport function intersectArcBounds(\n  center: number[],\n  radius: number,\n  start: number[],\n  end: number[],\n  bounds: TLBounds\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectArcRectangle(center, radius, start, end, [minX, minY], [width, height])\n}\n\n/* -------------------------------------------------- */\n/*                       Circle                       */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersections between a circle and a line segment.\n * @param c\n * @param r\n * @param a1\n * @param a2\n */\nexport function intersectCircleLineSegment(\n  c: number[],\n  r: number,\n  a1: number[],\n  a2: number[]\n): TLIntersection {\n  return intersectLineSegmentCircle(a1, a2, c, r)\n}\n\n/**\n * Find the intersections between a circle and a circle.\n * @param c1\n * @param r1\n * @param c2\n * @param r2\n */\nexport function intersectCircleCircle(\n  c1: number[],\n  r1: number,\n  c2: number[],\n  r2: number\n): TLIntersection {\n  let dx = c2[0] - c1[0],\n    dy = c2[1] - c1[1]\n\n  const d = Math.sqrt(dx * dx + dy * dy),\n    x = (d * d - r2 * r2 + r1 * r1) / (2 * d),\n    y = Math.sqrt(r1 * r1 - x * x)\n\n  dx /= d\n  dy /= d\n\n  return createIntersection(\n    'intersection',\n    [c1[0] + dx * x - dy * y, c1[1] + dy * x + dx * y],\n    [c1[0] + dx * x + dy * y, c1[1] + dy * x - dx * y]\n  )\n}\n\n/**\n * Find the intersections between a circle and a rectangle.\n * @param c\n * @param r\n * @param point\n * @param size\n */\nexport function intersectCircleRectangle(\n  c: number[],\n  r: number,\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  return intersectRectangleCircle(point, size, c, r)\n}\n\n/**\n * Find the intersections between a circle and a bounding box.\n * @param c\n * @param r\n * @param bounds\n */\nexport function intersectCircleBounds(c: number[], r: number, bounds: TLBounds): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectCircleRectangle(c, r, [minX, minY], [width, height])\n}\n\n/* -------------------------------------------------- */\n/*                       Ellipse                      */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersections between an ellipse and a ray.\n * @param center\n * @param rx\n * @param ry\n * @param rotation\n * @param point\n * @param direction\n */\nexport function intersectEllipseRay(\n  center: number[],\n  rx: number,\n  ry: number,\n  rotation: number,\n  point: number[],\n  direction: number[]\n): TLIntersection {\n  return intersectRayEllipse(point, direction, center, rx, ry, rotation)\n}\n\n/**\n * Find the intersections between an ellipse and a line segment.\n * @param center\n * @param rx\n * @param ry\n * @param rotation\n * @param a1\n * @param a2\n */\nexport function intersectEllipseLineSegment(\n  center: number[],\n  rx: number,\n  ry: number,\n  rotation = 0,\n  a1: number[],\n  a2: number[]\n): TLIntersection {\n  if (rx === ry) {\n    return intersectLineSegmentCircle(a1, a2, center, rx)\n  }\n\n  return intersectLineSegmentEllipse(a1, a2, center, rx, ry, rotation)\n}\n\n/**\n * Find the intersections between an ellipse and a rectangle.\n * @param center\n * @param rx\n * @param ry\n * @param rotation\n * @param point\n * @param size\n */\nexport function intersectEllipseRectangle(\n  center: number[],\n  rx: number,\n  ry: number,\n  rotation = 0,\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  if (rx === ry) {\n    return intersectRectangleCircle(point, size, center, rx)\n  }\n\n  return intersectRectangleEllipse(point, size, center, rx, ry, rotation)\n}\n\n/**\n * Find the intersections between an ellipse and an ellipse.\n * Adapted from https://gist.github.com/drawable/92792f59b6ff8869d8b1\n * @param _c1\n * @param _rx1\n * @param _ry1\n * @param _r1\n * @param _c2\n * @param _rx2\n * @param _ry2\n * @param _r2\n */\nexport function intersectEllipseEllipse(\n  _c1: number[],\n  _rx1: number,\n  _ry1: number,\n  _r1: number,\n  _c2: number[],\n  _rx2: number,\n  _ry2: number,\n  _r2: number\n): TLIntersection {\n  // TODO\n  return createIntersection('no intersection')\n}\n\n/**\n * Find the intersections between an ellipse and a circle.\n * @param c\n * @param rx\n * @param ry\n * @param rotation\n * @param c2\n * @param r2\n */\nexport function intersectEllipseCircle(\n  c: number[],\n  rx: number,\n  ry: number,\n  rotation: number,\n  c2: number[],\n  r2: number\n): TLIntersection {\n  return intersectEllipseEllipse(c, rx, ry, rotation, c2, r2, r2, 0)\n}\n\n/**\n * Find the intersections between an ellipse and a bounding box.\n * @param c\n * @param rx\n * @param ry\n * @param rotation\n * @param bounds\n */\nexport function intersectEllipseBounds(\n  c: number[],\n  rx: number,\n  ry: number,\n  rotation: number,\n  bounds: TLBounds\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectEllipseRectangle(c, rx, ry, rotation, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and a ray.\n * @param bounds\n * @param origin\n * @param direction\n */\nexport function intersectBoundsRay(\n  bounds: TLBounds,\n  origin: number[],\n  direction: number[]\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectRayRectangle(origin, direction, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and a line segment.\n * @param bounds\n * @param a1\n * @param a2\n */\nexport function intersectBoundsLineSegment(\n  bounds: TLBounds,\n  a1: number[],\n  a2: number[]\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectLineSegmentRectangle(a1, a2, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and a rectangle.\n * @param bounds\n * @param point\n * @param size\n */\nexport function intersectBoundsRectangle(\n  bounds: TLBounds,\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectRectangleRectangle(point, size, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and a bounding box.\n * @param bounds1\n * @param bounds2\n */\nexport function intersectBoundsBounds(bounds1: TLBounds, bounds2: TLBounds): TLIntersection[] {\n  return intersectRectangleRectangle(\n    [bounds1.minX, bounds1.minY],\n    [bounds1.width, bounds1.height],\n    [bounds2.minX, bounds2.minY],\n    [bounds2.width, bounds2.height]\n  )\n}\n\n/**\n * Find the intersections between a bounding box and an arc.\n * @param bounds\n * @param center\n * @param radius\n * @param start\n * @param end\n */\nexport function intersectBoundsArc(\n  bounds: TLBounds,\n  center: number[],\n  radius: number,\n  start: number[],\n  end: number[]\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectArcRectangle(center, radius, start, end, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and a circle.\n * @param bounds\n * @param c\n * @param r\n */\nexport function intersectBoundsCircle(bounds: TLBounds, c: number[], r: number): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectCircleRectangle(c, r, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and an ellipse.\n * @param bounds\n * @param c\n * @param rx\n * @param ry\n * @param rotation\n */\nexport function intersectBoundsEllipse(\n  bounds: TLBounds,\n  c: number[],\n  rx: number,\n  ry: number,\n  rotation = 0\n): TLIntersection[] {\n  const { minX, minY, width, height } = bounds\n  return intersectEllipseRectangle(c, rx, ry, rotation, [minX, minY], [width, height])\n}\n\n/**\n * Find the intersections between a bounding box and a polyline.\n * @param bounds\n * @param points\n */\nexport function intersectBoundsPolyline(bounds: TLBounds, points: number[][]): TLIntersection[] {\n  return intersectPolylineBounds(points, bounds)\n}\n\n/**\n * Find the intersections between a bounding box and a polygon.\n * @param bounds\n * @param points\n */\nexport function intersectBoundsPolygon(bounds: TLBounds, points: number[][]): TLIntersection[] {\n  return intersectPolygonBounds(points, bounds)\n}\n\n/* -------------------------------------------------- */\n/*                      Polyline                      */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersections between a polyline and a line segment.\n * @param points\n * @param a1\n * @param a2\n */\nexport function intersectPolylineLineSegment(\n  points: number[][],\n  a1: number[],\n  a2: number[]\n): TLIntersection {\n  return intersectLineSegmentPolyline(a1, a2, points)\n}\n\n/**\n * Find the intersections between a polyline and a rectangle.\n * @param points\n * @param point\n * @param size\n */\nexport function intersectPolylineRectangle(\n  points: number[][],\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  return intersectRectanglePolyline(point, size, points)\n}\n\n/**\n * Find the intersections between a polyline and a bounding box.\n * @param points\n * @param bounds\n */\nexport function intersectPolylineBounds(points: number[][], bounds: TLBounds): TLIntersection[] {\n  return intersectRectanglePolyline(\n    [bounds.minX, bounds.minY],\n    [bounds.width, bounds.height],\n    points\n  )\n}\n\n/* -------------------------------------------------- */\n/*                       Polygon                      */\n/* -------------------------------------------------- */\n\n/**\n * Find the intersections between a polygon nd a line segment.\n * @param points\n * @param a1\n * @param a2\n */\nexport function intersectPolygonLineSegment(\n  points: number[][],\n  a1: number[],\n  a2: number[]\n): TLIntersection {\n  return intersectLineSegmentPolyline(a1, a2, points)\n}\n\n/**\n * Find the intersections between a polygon and a rectangle.\n * @param points\n * @param point\n * @param size\n */\nexport function intersectPolygonRectangle(\n  points: number[][],\n  point: number[],\n  size: number[]\n): TLIntersection[] {\n  return intersectRectanglePolyline(point, size, points)\n}\n\n/**\n * Find the intersections between a polygon and a bounding box.\n * @param points\n * @param bounds\n */\nexport function intersectPolygonBounds(points: number[][], bounds: TLBounds): TLIntersection[] {\n  return intersectRectanglePolygon(\n    [bounds.minX, bounds.minY],\n    [bounds.width, bounds.height],\n    points\n  )\n}\n\n/**\n * Find the intersections between a rectangle and a ray.\n * @param point\n * @param size\n * @param rotation\n * @param origin\n * @param direction\n */\nexport function intersectRayPolygon(\n  origin: number[],\n  direction: number[],\n  points: number[][]\n): TLIntersection[] {\n  const sideIntersections = pointsToLineSegments(points, true).reduce<TLIntersection[]>(\n    (acc, [a1, a2], i) => {\n      const intersection = intersectRayLineSegment(origin, direction, a1, a2)\n\n      if (intersection) {\n        acc.push(createIntersection(i.toString(), ...intersection.points))\n      }\n\n      return acc\n    },\n    []\n  )\n\n  return sideIntersections.filter((int) => int.didIntersect)\n}\n\nexport function pointsToLineSegments(points: number[][], closed = false) {\n  const segments = []\n  for (let i = 1; i < points.length; i++) segments.push([points[i - 1], points[i]])\n  if (closed) segments.push([points[points.length - 1], points[0]])\n  return segments\n}\n"],
  "mappings": "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",
  "names": ["e"]
}
